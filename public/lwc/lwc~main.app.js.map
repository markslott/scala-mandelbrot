{"version":3,"sources":["webpack:///./node_modules/@lwc/engine/dist/engine.cjs.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D,SAAS;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,UAAU,GAAG,IAAI;AAC3E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mHAAmH;AACnH;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,KAAK;AAC7B,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAyC;AACxD,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;;AAEpC;AACA,aAAa,IAAI,IAAI,sBAAsB;AAC3C;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,gDAAgD,IAAI,gBAAgB,IAAI,2DAA2D,6BAA6B;AAChK;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB,oBAAoB,aAAa;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA,0BAA0B,QAAQ;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAAK,KAAK,KAAK;AACjC;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,gBAAgB,oDAAoD,aAAa,oCAAoC,KAAK;AACzK,0EAA0E,gBAAgB,oCAAoC,aAAa,oCAAoC,KAAK,KAAK;AACzL;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,mJAAmJ,GAAG,6CAA6C;AACnM;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,sJAAsJ,GAAG,6CAA6C;AACtM;;AAEA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;;AAEA,KAAK;AACL;AACA,GAAG;AACH;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,gBAAgB,oDAAoD,eAAe,oCAAoC,KAAK;AAC3K,0EAA0E,gBAAgB,oCAAoC,cAAc,oCAAoC,KAAK,KAAK;AAC1L;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8IAA8I,oBAAoB;;AAElK;AACA;AACA;AACA,WAAW;;AAEX;AACA,4CAA4C,KAAK,0BAA0B,oBAAoB;AAC/F;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wDAAwD,SAAS;;AAEjE;AACA;AACA,SAAS;AACT,iEAAiE,UAAU;AAC3E;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,SAAS;AAC1D;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,gCAAgC;;AAEjC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,uEAAuE,QAAQ;AAC/E;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,QAAQ;AACb;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC;AACzC;;AAEA,gCAAgC;AAChC;;AAEA,wCAAwC;;AAExC;AACA,GAAG;AACH;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,qDAAqD,GAAG;AACxD;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qCAAqC;;AAErC;AACA,wCAAwC,OAAO;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,sCAAsC,IAAI,8CAA8C,gBAAgB,qDAAqD;;AAE7J;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA,sLAAsL,WAAW;AACjM;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;;AAEA;AACA,2CAA2C,gBAAgB,qBAAqB,gBAAgB;AAChG;AACA;;AAEA;AACA,CAAC;;AAED;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,4GAA4G;;AAE5G;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA;AACA,wLAAwL,WAAW;AACnM;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,wDAAwD,mBAAmB,OAAO,gBAAgB;AAClG;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,oGAAoG,mBAAmB,QAAQ,gBAAgB;AAC/I;;AAEA;;AAEA,MAAM,SAAoB;AAC1B,2FAA2F,mBAAmB,OAAO,gBAAgB;AACrI;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,yEAAyE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE,sBAAsB,eAAe;AAC1K;;AAEA;AACA,WAAW;AACX,mEAAmE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE;AAC/H;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA,uBAAuB;;AAEvB;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAoB;AAC9B,0CAA0C,IAAI,OAAO,qBAAqB;AAC1E;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,oCAAoC,GAAG;AACvC;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA,YAAY,GAAG,GAAG,oBAAoB;AACtC,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA,cAAc,IAAI,GAAG,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,+CAA+C,eAAe,uBAAuB,IAAI;AACzF;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA,mBAAmB,IAAI,GAAG,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,cAAc;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,+BAA+B,gBAAgB;AAC/C;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,wDAAwD,GAAG;AAC5D;;;AAGA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB,KAAK,MAAM,KAAK,OAAO;AACvD;;AAEA;AACA,YAAY,oBAAoB,KAAK,MAAM;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,wGAAwG,6BAA6B,aAAa,SAAS,OAAO,GAAG;;AAErK;AACA;AACA;AACA,uDAAuD,SAAS,OAAO,GAAG;AAC1E;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2CAA2C,GAAG,qBAAqB,SAAS;AAC5E;AACA,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B,kHAAkH,eAAe;AACjI;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA,qFAAqF,GAAG,qEAAqE,YAAY,uCAAuC,eAAe;AAC/N;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,mEAAmE;;AAEnE;AACA;;AAEA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B,2GAA2G,YAAY,IAAI;;AAE3H;AACA,OAAO;AACP;;;AAGA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA;AACA,iDAAiD;;AAEjD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG,EAAE;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,QAAQ,SAAoB;AAC5B,wEAAwE,WAAW,OAAO,GAAG;AAC7F;;AAEA;AACA,GAAG;AACH,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG,EAAE;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,iHAAiH,qBAAqB;AACtI,2GAA2G,qBAAqB;AAChI;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM,SAAoB;AAC1B,oCAAoC,GAAG;AACvC;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,2CAA2C,GAAG,+DAA+D,OAAO;AACpH;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA,6DAA6D,GAAG;AAChE,mEAAmE,GAAG,wCAAwC,gBAAgB;AAC9H,qEAAqE,GAAG,+CAA+C,gBAAgB;AACvI;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH;;AAEnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,2FAA2F,SAAS;AACpG;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,2FAA2F,SAAS;AACpG;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC;AACA,wBAAwB,KAAK,oDAAoD,SAAS,8EAA8E,KAAK;AAC7K;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,SAAS;AAClI,+EAA+E,gBAAgB,+EAA+E,GAAG,GAAG,SAAS;AAC7L,uEAAuE,oBAAoB;AAC3F,sFAAsF,SAAS,SAAS,SAAS,OAAO,GAAG;AAC3H;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,qIAAqI,mBAAmB;AACxJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA,uBAAuB;;AAEvB;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,6CAA6C,gBAAgB,oDAAoD,GAAG,oCAAoC,KAAK;AAC7J,wEAAwE,gBAAgB,oCAAoC,GAAG,oCAAoC,KAAK;AACxK,uGAAuG,GAAG,cAAc,KAAK,4CAA4C,SAAS;AAClL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,qEAAqE,oBAAoB;AACzF;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,qEAAqE,oBAAoB;AACzF;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,oJAAoJ,oBAAoB;AACxK;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,wIAAwI,oBAAoB;AAC5J;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,2IAA2I,oBAAoB;AAC/J;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,+IAA+I,oBAAoB;AACnK;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,iJAAiJ,oBAAoB;AACrK;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,uCAAuC;;AAEvC,oEAAoE,GAAG;AACvE;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sBAAsB,YAAY;AAClC;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA,IAAI,SAAoB;AACxB;AACA;;AAEA;AACA,gDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;AAEhB;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,8EAA8E,gCAAgC;AAC9G;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,iBAAiB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,cAAc;AACnB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uDAAuD,eAAe,QAAQ,eAAe,MAAM,eAAe;AAClH;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,0DAA0D,eAAe,QAAQ,eAAe,MAAM,eAAe;AACrH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,8EAA8E,eAAe,MAAM,eAAe;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,YAAY;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uEAAuE,eAAe,MAAM,eAAe;AAC3G;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,kEAAkE,eAAe,QAAQ,eAAe,MAAM,eAAe;AAC7H;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,SAAoB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mFAAmF;;AAEnF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,mCAAmC;;AAEnC,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH,QAAQ,SAAoB;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;;AAEA;AACA;;AAEA;AACA,+BAA+B,aAAa,4BAA4B,KAAK;;AAE7E,QAAQ,SAAoB;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,sCAAsC,KAAK;AAC3C;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA,uCAAuC,KAAK;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,kHAAkH,mBAAmB,iBAAiB,OAAO;;AAE7J;AACA,yGAAyG,mBAAmB,0BAA0B,OAAO;AAC7J;AACA;;AAEA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC;AACA,wBAAwB,KAAK,oDAAoD,cAAc,8EAA8E,KAAK;AAClL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,0EAA0E,cAAc,MAAM,KAAK,uDAAuD,cAAc,KAAK;AAC7K;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,SAAoB;AAC9B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO,UAAU,SAAoB;AACrC,uEAAuE,cAAc,MAAM,GAAG;AAC9F;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,4EAA4E,YAAY,2BAA2B,WAAW,gBAAgB,6BAA6B;AAC3K;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,sBAAsB;AAClF,GAAG;;;AAGH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,mEAAmE,sBAAsB;AACzF;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,+BAA+B;AAC/B,wDAAwD,eAAe,8DAA8D,SAAS;;AAE9I,+CAA+C,SAAS,gBAAgB,SAAS;AACjF;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA;;;AAGA;;AAEA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG,iEAAiE;;;AAGpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,KAAK;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK,MAAM;;AAEX,gBAAgB;;AAEhB;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B,0FAA0F,GAAG;AAC7F;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B,kGAAkG,IAAI;AACtG;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA,2BAA2B,SAAS,IAAI,oBAAoB;AAC5D;AACA,GAAG;;;AAGH,yCAAyC;;AAEzC;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,sFAAsF,GAAG;AACzF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,YAAY,SAAoB;AAChC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,6JAA6J,eAAe;AAC5K;;AAEA;AACA,sBAAsB;;AAEtB,mCAAmC,SAAS;AAC5C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP,yDAAyD;AACzD;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW;AACX;;AAEA,+BAA+B;;AAE/B;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,wDAAwD,GAAG;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,MAAM;;AAET,mDAAmD,QAAQ;AAC3D,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,iEAAiE;AACjE;AACA;AACA;;AAEA,oBAAoB,SAAS,GAAG,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA,0BAA0B;;AAE1B,UAAU,SAAoB;AAC9B;AACA,OAAO;;;AAGP;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd,CAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,wGAAwG,kBAAkB;AAC1H;;AAEA;;AAEA;AACA;AACA;;AAEA,6DAA6D;;AAE7D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,GAAG,EAAE;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"lwc~main.app.js","sourcesContent":["/* proxy-compat-disable */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect() {\n  // Don't apply polyfill when ProxyCompat is enabled.\n  if ('getKey' in Proxy) {\n    return false;\n  }\n\n  const proxy = new Proxy([3, 4], {});\n  const res = [1, 2].concat(proxy);\n  return res.length !== 4;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  isConcatSpreadable\n} = Symbol;\nconst {\n  isArray\n} = Array;\nconst {\n  slice: ArraySlice,\n  unshift: ArrayUnshift,\n  shift: ArrayShift\n} = Array.prototype;\n\nfunction isObject(O) {\n  return typeof O === 'object' ? O !== null : typeof O === 'function';\n} // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\n\n\nfunction isSpreadable(O) {\n  if (!isObject(O)) {\n    return false;\n  }\n\n  const spreadable = O[isConcatSpreadable];\n  return spreadable !== undefined ? Boolean(spreadable) : isArray(O);\n} // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat\n\n\nfunction ArrayConcatPolyfill(..._args) {\n  const O = Object(this);\n  const A = [];\n  let N = 0;\n  const items = ArraySlice.call(arguments);\n  ArrayUnshift.call(items, O);\n\n  while (items.length) {\n    const E = ArrayShift.call(items);\n\n    if (isSpreadable(E)) {\n      let k = 0;\n      const length = E.length;\n\n      for (k; k < length; k += 1, N += 1) {\n        if (k in E) {\n          const subElement = E[k];\n          A[N] = subElement;\n        }\n      }\n    } else {\n      A[N] = E;\n      N += 1;\n    }\n  }\n\n  return A;\n}\n\nfunction apply() {\n  Array.prototype.concat = ArrayConcatPolyfill;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nif (detect()) {\n  apply();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$1(propName) {\n  return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  hasAttribute,\n  getAttribute,\n  setAttribute,\n  setAttributeNS,\n  removeAttribute,\n  removeAttributeNS\n} = Element.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`\n\nconst ARIA_REGEX = /^aria/;\nconst nodeToAriaPropertyValuesMap = new WeakMap();\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst {\n  replace: StringReplace,\n  toLowerCase: StringToLowerCase\n} = String.prototype;\n\nfunction getAriaPropertyMap(elm) {\n  let map = nodeToAriaPropertyValuesMap.get(elm);\n\n  if (map === undefined) {\n    map = {};\n    nodeToAriaPropertyValuesMap.set(elm, map);\n  }\n\n  return map;\n}\n\nfunction getNormalizedAriaPropertyValue(value) {\n  return value == null ? null : value + '';\n}\n\nfunction createAriaPropertyPropertyDescriptor(propName, attrName) {\n  return {\n    get() {\n      const map = getAriaPropertyMap(this);\n\n      if (hasOwnProperty.call(map, propName)) {\n        return map[propName];\n      } // otherwise just reflect what's in the attribute\n\n\n      return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;\n    },\n\n    set(newValue) {\n      const normalizedValue = getNormalizedAriaPropertyValue(newValue);\n      const map = getAriaPropertyMap(this);\n      map[propName] = normalizedValue; // reflect into the corresponding attribute\n\n      if (newValue === null) {\n        removeAttribute.call(this, attrName);\n      } else {\n        setAttribute.call(this, attrName, newValue);\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n\nfunction patch(propName) {\n  // Typescript is inferring the wrong function type for this particular\n  // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const replaced = StringReplace.call(propName, ARIA_REGEX, 'aria-');\n  const attrName = StringToLowerCase.call(replaced);\n  const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);\n  Object.defineProperty(Element.prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// https://wicg.github.io/aom/spec/aria-reflection.html\n\nconst ElementPrototypeAriaPropertyNames = ['ariaAutoComplete', 'ariaChecked', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaLabel', 'ariaLevel', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaSelected', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'ariaLive', 'ariaRelevant', 'ariaAtomic', 'ariaBusy', 'ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns', 'ariaPosInSet', 'ariaSetSize', 'ariaColCount', 'ariaColIndex', 'ariaDetails', 'ariaErrorMessage', 'ariaKeyShortcuts', 'ariaModal', 'ariaPlaceholder', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaColSpan', 'role'];\n/**\n * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in\n * ARIA 1.1 and do not have corresponding IDL attributes.\n */\n\nfor (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n  const propName = ElementPrototypeAriaPropertyNames[i];\n\n  if (detect$1(propName)) {\n    patch(propName);\n  }\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n  if (!value) {\n    throw new Error(`Invariant Violation: ${msg}`);\n  }\n}\n\nfunction isTrue(value, msg) {\n  if (!value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction isFalse(value, msg) {\n  if (value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction fail(msg) {\n  throw new Error(msg);\n}\n\nvar assert =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  invariant: invariant,\n  isTrue: isTrue,\n  isFalse: isFalse,\n  fail: fail\n});\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst {\n  assign,\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  hasOwnProperty: hasOwnProperty$1,\n  keys,\n  seal,\n  setPrototypeOf\n} = Object;\nconst {\n  isArray: isArray$1\n} = Array;\nconst {\n  filter: ArrayFilter,\n  find: ArrayFind,\n  forEach,\n  indexOf: ArrayIndexOf,\n  join: ArrayJoin,\n  map: ArrayMap,\n  push: ArrayPush,\n  reduce: ArrayReduce,\n  reverse: ArrayReverse,\n  slice: ArraySlice$1,\n  splice: ArraySplice,\n  unshift: ArrayUnshift$1\n} = Array.prototype;\nconst {\n  charCodeAt: StringCharCodeAt,\n  replace: StringReplace$1,\n  slice: StringSlice,\n  toLowerCase: StringToLowerCase$1\n} = String.prototype;\n\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\n\nfunction isNull(obj) {\n  return obj === null;\n}\n\nfunction isTrue$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1(obj) {\n  return obj === false;\n}\n\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject$1(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n\nconst OtS = {}.toString;\n\nfunction toString(obj) {\n  if (obj && obj.toString) {\n    // Arrays might hold objects with \"null\" prototype So using\n    // Array.prototype.toString directly will cause an error Iterate through\n    // all the items and handle individually.\n    if (isArray$1(obj)) {\n      return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n    }\n\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS.call(obj);\n  } else {\n    return obj + emptyString;\n  }\n}\n\nfunction getPropertyDescriptor(o, p) {\n  do {\n    const d = getOwnPropertyDescriptor(o, p);\n\n    if (!isUndefined(d)) {\n      return d;\n    }\n\n    o = getPrototypeOf(o);\n  } while (o !== null);\n}\n\nconst emptyString = '';\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when transpiling.\n */\n\nconst hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';\n\nfunction createHiddenField(key, namespace) {\n  return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;\n}\n\nconst hiddenFieldsMap = new WeakMap();\n\nfunction setHiddenField(o, field, value) {\n  let valuesByField = hiddenFieldsMap.get(o);\n\n  if (isUndefined(valuesByField)) {\n    valuesByField = create(null);\n    hiddenFieldsMap.set(o, valuesByField);\n  }\n\n  valuesByField[field] = value;\n}\n\nfunction getHiddenField(o, field) {\n  const valuesByField = hiddenFieldsMap.get(o);\n\n  if (!isUndefined(valuesByField)) {\n    return valuesByField[field];\n  }\n}\n/** version: 1.1.16 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'tabIndex', 'title']; // Few more exceptions that are using the attribute name to match the property in lowercase.\n// this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx\n// and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n// Note: this list most be in sync with the compiler as well.\n\nconst HTMLPropertyNamesWithLowercasedReflectiveAttributes = ['accessKey', 'readOnly', 'tabIndex', 'bgColor', 'colSpan', 'rowSpan', 'contentEditable', 'dateTime', 'formAction', 'isMap', 'maxLength', 'useMap'];\n\nfunction offsetPropertyErrorMessage(name) {\n  return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n} // Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n\n\nconst globalHTMLProperties = assign(create(null), {\n  accessKey: {\n    attribute: 'accesskey'\n  },\n  accessKeyLabel: {\n    readOnly: true\n  },\n  className: {\n    attribute: 'class',\n    error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'\n  },\n  contentEditable: {\n    attribute: 'contenteditable'\n  },\n  dataset: {\n    readOnly: true,\n    error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\"\n  },\n  dir: {\n    attribute: 'dir'\n  },\n  draggable: {\n    attribute: 'draggable'\n  },\n  dropzone: {\n    attribute: 'dropzone',\n    readOnly: true\n  },\n  hidden: {\n    attribute: 'hidden'\n  },\n  id: {\n    attribute: 'id'\n  },\n  inputMode: {\n    attribute: 'inputmode'\n  },\n  lang: {\n    attribute: 'lang'\n  },\n  slot: {\n    attribute: 'slot',\n    error: 'Using the `slot` property is an anti-pattern.'\n  },\n  spellcheck: {\n    attribute: 'spellcheck'\n  },\n  style: {\n    attribute: 'style'\n  },\n  tabIndex: {\n    attribute: 'tabindex'\n  },\n  title: {\n    attribute: 'title'\n  },\n  translate: {\n    attribute: 'translate'\n  },\n  // additional \"global attributes\" that are not present in the link above.\n  isContentEditable: {\n    readOnly: true\n  },\n  offsetHeight: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetHeight')\n  },\n  offsetLeft: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetLeft')\n  },\n  offsetParent: {\n    readOnly: true\n  },\n  offsetTop: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetTop')\n  },\n  offsetWidth: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetWidth')\n  },\n  role: {\n    attribute: 'role'\n  }\n});\nconst AttrNameToPropNameMap = create(null);\nconst PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements\n\nforEach.call(ElementPrototypeAriaPropertyNames, propName => {\n  // Typescript is inferring the wrong function type for this particular\n  // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(defaultDefHTMLPropertyNames, propName => {\n  const attrName = StringToLowerCase$1.call(propName);\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, propName => {\n  const attrName = StringToLowerCase$1.call(propName);\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nconst CAMEL_REGEX = /-([a-z])/g;\n/**\n * This method maps between attribute names\n * and the corresponding property name.\n */\n\nfunction getPropNameFromAttrName(attrName) {\n  if (isUndefined(AttrNameToPropNameMap[attrName])) {\n    AttrNameToPropNameMap[attrName] = StringReplace$1.call(attrName, CAMEL_REGEX, g => g[1].toUpperCase());\n  }\n\n  return AttrNameToPropNameMap[attrName];\n}\nconst CAPS_REGEX = /[A-Z]/g;\n/**\n * This method maps between property names\n * and the corresponding attribute name.\n */\n\nfunction getAttrNameFromPropName(propName) {\n  if (isUndefined(PropNameToAttrNameMap[propName])) {\n    PropNameToAttrNameMap[propName] = StringReplace$1.call(propName, CAPS_REGEX, match => '-' + match.toLowerCase());\n  }\n\n  return PropNameToAttrNameMap[propName];\n}\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n  return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(_elm, _key) {\n  controlledElement = null;\n  controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n  controlledElement = elm;\n  controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\n\nfunction flushCallbackQueue() {\n  if (process.env.NODE_ENV !== 'production') {\n    if (nextTickCallbackQueue.length === 0) {\n      throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n    }\n  }\n\n  const callbacks = nextTickCallbackQueue;\n  nextTickCallbackQueue = []; // reset to a new queue\n\n  for (let i = 0, len = callbacks.length; i < len; i += 1) {\n    callbacks[i]();\n  }\n}\n\nfunction addCallbackToNextTick(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isFunction(callback)) {\n      throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n    }\n  }\n\n  if (nextTickCallbackQueue.length === 0) {\n    Promise.resolve().then(flushCallbackQueue);\n  }\n\n  ArrayPush.call(nextTickCallbackQueue, callback);\n}\nfunction isCircularModuleDependency(value) {\n  return hasOwnProperty$1.call(value, '__circular__');\n}\n/**\n * When LWC is used in the context of an Aura application, the compiler produces AMD\n * modules, that doesn't resolve properly circular dependencies between modules. In order\n * to circumvent this issue, the module loader returns a factory with a symbol attached\n * to it.\n *\n * This method returns the resolved value if it received a factory as argument. Otherwise\n * it returns the original value.\n */\n\nfunction resolveCircularModuleDependency(fn) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isFunction(fn)) {\n      throw new TypeError(`Circular module dependency must be a function.`);\n    }\n  }\n\n  return fn();\n}\nconst useSyntheticShadow = hasOwnProperty$1.call(Element.prototype, '$shadowToken$');\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n  // Element.prototype.tagName getter might be poisoned. We need to use a try/catch to protect the\n  // engine internal when accessing the tagName property.\n  try {\n    return `<${StringToLowerCase$1.call(vm.elm.tagName)}>`;\n  } catch (error) {\n    return '<invalid-tag-name>';\n  }\n} // TODO [#1695]: Unify getComponentStack and getErrorComponentStack\n\nfunction getComponentStack(vm) {\n  const stack = [];\n  let prefix = '';\n\n  while (!isNull(vm.owner)) {\n    ArrayPush.call(stack, prefix + getComponentTag(vm));\n    vm = vm.owner;\n    prefix += '\\t';\n  }\n\n  return ArrayJoin.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n  const wcStack = [];\n  let currentVm = vm;\n\n  while (!isNull(currentVm)) {\n    ArrayPush.call(wcStack, getComponentTag(currentVm));\n    currentVm = currentVm.owner;\n  }\n\n  return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction logError(message, vm) {\n  let msg = `[LWC error]: ${message}`;\n\n  if (!isUndefined(vm)) {\n    msg = `${msg}\\n${getComponentStack(vm)}`;\n  }\n\n  if (process.env.NODE_ENV === 'test') {\n    /* eslint-disable-next-line no-console */\n    console.error(msg);\n    return;\n  }\n\n  try {\n    throw new Error(msg);\n  } catch (e) {\n    /* eslint-disable-next-line no-console */\n    console.error(e);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction handleEvent(event, vnode) {\n  const {\n    type\n  } = event;\n  const {\n    data: {\n      on\n    }\n  } = vnode;\n  const handler = on && on[type]; // call event handler if exists\n\n  if (handler) {\n    handler.call(undefined, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event) {\n    handleEvent(event, handler.vnode);\n  };\n}\n\nfunction updateAllEventListeners(oldVnode, vnode) {\n  if (isUndefined(oldVnode.listener)) {\n    createAllEventListeners(vnode);\n  } else {\n    vnode.listener = oldVnode.listener;\n    vnode.listener.vnode = vnode;\n  }\n}\n\nfunction createAllEventListeners(vnode) {\n  const {\n    data: {\n      on\n    }\n  } = vnode;\n\n  if (isUndefined(on)) {\n    return;\n  }\n\n  const elm = vnode.elm;\n  const listener = vnode.listener = createListener();\n  listener.vnode = vnode;\n  let name;\n\n  for (name in on) {\n    elm.addEventListener(name, listener);\n  }\n}\n\nvar modEvents = {\n  update: updateAllEventListeners,\n  create: createAllEventListeners\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\n\nfunction updateAttrs(oldVnode, vnode) {\n  const {\n    data: {\n      attrs\n    }\n  } = vnode;\n\n  if (isUndefined(attrs)) {\n    return;\n  }\n\n  let {\n    data: {\n      attrs: oldAttrs\n    }\n  } = oldVnode;\n\n  if (oldAttrs === attrs) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isUndefined(oldAttrs) || keys(oldAttrs).join(',') === keys(attrs).join(','), `vnode.data.attrs cannot change shape.`);\n  }\n\n  const elm = vnode.elm;\n  let key;\n  oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes\n  // this routine is only useful for data-* attributes in all kind of elements\n  // and aria-* in standard elements (custom elements will use props for these)\n\n  for (key in attrs) {\n    const cur = attrs[key];\n    const old = oldAttrs[key];\n\n    if (old !== cur) {\n      unlockAttribute(elm, key);\n\n      if (StringCharCodeAt.call(key, 3) === ColonCharCode) {\n        // Assume xml namespace\n        elm.setAttributeNS(xmlNS, key, cur);\n      } else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {\n        // Assume xlink namespace\n        elm.setAttributeNS(xlinkNS, key, cur);\n      } else if (isNull(cur)) {\n        elm.removeAttribute(key);\n      } else {\n        elm.setAttribute(key, cur);\n      }\n\n      lockAttribute();\n    }\n  }\n}\n\nconst emptyVNode = {\n  data: {}\n};\nvar modAttrs = {\n  create: vnode => updateAttrs(emptyVNode, vnode),\n  update: updateAttrs\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction isLiveBindingProp(sel, key) {\n  // For properties with live bindings, we read values from the DOM element\n  // instead of relying on internally tracked values.\n  return sel === 'input' && (key === 'value' || key === 'checked');\n}\n\nfunction update(oldVnode, vnode) {\n  const props = vnode.data.props;\n\n  if (isUndefined(props)) {\n    return;\n  }\n\n  const oldProps = oldVnode.data.props;\n\n  if (oldProps === props) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isUndefined(oldProps) || keys(oldProps).join(',') === keys(props).join(','), 'vnode.data.props cannot change shape.');\n  }\n\n  const elm = vnode.elm;\n  const isFirstPatch = isUndefined(oldProps);\n  const {\n    sel\n  } = vnode;\n\n  for (const key in props) {\n    const cur = props[key];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(key in elm)) {\n        // TODO [#1297]: Move this validation to the compiler\n        assert.fail(`Unknown public property \"${key}\" of element <${sel}>. This is likely a typo on the corresponding attribute \"${getAttrNameFromPropName(key)}\".`);\n      }\n    } // if it is the first time this element is patched, or the current value is different to the previous value...\n\n\n    if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {\n      elm[key] = cur;\n    }\n  }\n}\n\nconst emptyVNode$1 = {\n  data: {}\n};\nvar modProps = {\n  create: vnode => update(emptyVNode$1, vnode),\n  update\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\n\nfunction getMapFromClassName(className) {\n  // Intentionally using == to match undefined and null values from computed style attribute\n  if (className == null) {\n    return EmptyObject;\n  } // computed class names must be string\n\n\n  className = isString(className) ? className : className + '';\n  let map = classNameToClassMap[className];\n\n  if (map) {\n    return map;\n  }\n\n  map = create(null);\n  let start = 0;\n  let o;\n  const len = className.length;\n\n  for (o = 0; o < len; o++) {\n    if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n      if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n      }\n\n      start = o + 1;\n    }\n  }\n\n  if (o > start) {\n    map[StringSlice.call(className, start, o)] = true;\n  }\n\n  classNameToClassMap[className] = map;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // just to make sure that this object never changes as part of the diffing algo\n    freeze(map);\n  }\n\n  return map;\n}\n\nfunction updateClassAttribute(oldVnode, vnode) {\n  const {\n    elm,\n    data: {\n      className: newClass\n    }\n  } = vnode;\n  const {\n    data: {\n      className: oldClass\n    }\n  } = oldVnode;\n\n  if (oldClass === newClass) {\n    return;\n  }\n\n  const {\n    classList\n  } = elm;\n  const newClassMap = getMapFromClassName(newClass);\n  const oldClassMap = getMapFromClassName(oldClass);\n  let name;\n\n  for (name in oldClassMap) {\n    // remove only if it is not in the new class collection and it is not set from within the instance\n    if (isUndefined(newClassMap[name])) {\n      classList.remove(name);\n    }\n  }\n\n  for (name in newClassMap) {\n    if (isUndefined(oldClassMap[name])) {\n      classList.add(name);\n    }\n  }\n}\n\nconst emptyVNode$2 = {\n  data: {}\n};\nvar modComputedClassName = {\n  create: vnode => updateClassAttribute(emptyVNode$2, vnode),\n  update: updateClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction updateStyleAttribute(oldVnode, vnode) {\n  const {\n    style: newStyle\n  } = vnode.data;\n\n  if (oldVnode.data.style === newStyle) {\n    return;\n  }\n\n  const elm = vnode.elm;\n  const {\n    style\n  } = elm;\n\n  if (!isString(newStyle) || newStyle === '') {\n    removeAttribute.call(elm, 'style');\n  } else {\n    style.cssText = newStyle;\n  }\n}\n\nconst emptyVNode$3 = {\n  data: {}\n};\nvar modComputedStyle = {\n  create: vnode => updateStyleAttribute(emptyVNode$3, vnode),\n  update: updateStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\n\nfunction createClassAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      classMap\n    }\n  } = vnode;\n\n  if (isUndefined(classMap)) {\n    return;\n  }\n\n  const {\n    classList\n  } = elm;\n\n  for (const name in classMap) {\n    classList.add(name);\n  }\n}\n\nvar modStaticClassName = {\n  create: createClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\n\nfunction createStyleAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      styleMap\n    }\n  } = vnode;\n\n  if (isUndefined(styleMap)) {\n    return;\n  }\n\n  const {\n    style\n  } = elm;\n\n  for (const name in styleMap) {\n    style[name] = styleMap[name];\n  }\n}\n\nvar modStaticStyle = {\n  create: createStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction createContext(vnode) {\n  const {\n    data: {\n      context\n    }\n  } = vnode;\n\n  if (isUndefined(context)) {\n    return;\n  }\n\n  const elm = vnode.elm;\n  const vm = getAssociatedVMIfPresent(elm);\n\n  if (!isUndefined(vm)) {\n    assign(vm.context, context);\n  }\n}\n\nconst contextModule = {\n  create: createContext\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/**\n@license\nCopyright (c) 2015 Simon Friis Vindum.\nThis code may only be used under the MIT License found at\nhttps://github.com/snabbdom/snabbdom/blob/master/LICENSE\nCode distributed by Snabbdom as part of the Snabbdom project at\nhttps://github.com/snabbdom/snabbdom/\n*/\nfunction isUndef(s) {\n  return s === undefined;\n}\n\nfunction sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction isVNode(vnode) {\n  return vnode != null;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  const map = {};\n  let j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys\n\n  for (j = beginIdx; j <= endIdx; ++j) {\n    ch = children[j];\n\n    if (isVNode(ch)) {\n      key = ch.key;\n\n      if (key !== undefined) {\n        map[key] = j;\n      }\n    }\n  }\n\n  return map;\n}\n\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx];\n\n    if (isVNode(ch)) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, parentElm, before);\n    }\n  }\n}\n\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]; // text nodes do not have logic associated to them\n\n    if (isVNode(ch)) {\n      ch.hook.remove(ch, parentElm);\n    }\n  }\n}\n\nfunction updateDynamicChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let oldKeyToIdx;\n  let idxInOld;\n  let elmToMove;\n  let before;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (!isVNode(oldStartVnode)) {\n      oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n    } else if (!isVNode(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (!isVNode(newStartVnode)) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (!isVNode(newEndVnode)) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      // Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode);\n      newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.elm.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      // Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode);\n      newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n      }\n\n      idxInOld = oldKeyToIdx[newStartVnode.key];\n\n      if (isUndef(idxInOld)) {\n        // New element\n        newStartVnode.hook.create(newStartVnode);\n        newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        elmToMove = oldCh[idxInOld];\n\n        if (isVNode(elmToMove)) {\n          if (elmToMove.sel !== newStartVnode.sel) {\n            // New element\n            newStartVnode.hook.create(newStartVnode);\n            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n          } else {\n            patchVnode(elmToMove, newStartVnode);\n            oldCh[idxInOld] = undefined;\n            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n  }\n\n  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n    if (oldStartIdx > oldEndIdx) {\n      const n = newCh[newEndIdx + 1];\n      before = isVNode(n) ? n.elm : null;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n    } else {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n}\nfunction updateStaticChildren(parentElm, oldCh, newCh) {\n  const {\n    length\n  } = newCh;\n\n  if (oldCh.length === 0) {\n    // the old list is empty, we can directly insert anything new\n    addVnodes(parentElm, null, newCh, 0, length);\n    return;\n  } // if the old list is not empty, the new list MUST have the same\n  // amount of nodes, that's why we call this static children\n\n\n  let referenceElm = null;\n\n  for (let i = length - 1; i >= 0; i -= 1) {\n    const vnode = newCh[i];\n    const oldVNode = oldCh[i];\n\n    if (vnode !== oldVNode) {\n      if (isVNode(oldVNode)) {\n        if (isVNode(vnode)) {\n          // both vnodes must be equivalent, and se just need to patch them\n          patchVnode(oldVNode, vnode);\n          referenceElm = vnode.elm;\n        } else {\n          // removing the old vnode since the new one is null\n          oldVNode.hook.remove(oldVNode, parentElm);\n        }\n      } else if (isVNode(vnode)) {\n        // this condition is unnecessary\n        vnode.hook.create(vnode); // insert the new node one since the old one is null\n\n        vnode.hook.insert(vnode, parentElm, referenceElm);\n        referenceElm = vnode.elm;\n      }\n    }\n  }\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  if (oldVnode !== vnode) {\n    vnode.elm = oldVnode.elm;\n    vnode.hook.update(oldVnode, vnode);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction generateDataDescriptor(options) {\n  return assign({\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }, options);\n}\n\nfunction generateAccessorDescriptor(options) {\n  return assign({\n    configurable: true,\n    enumerable: true\n  }, options);\n}\n\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = false;\n}\n\nfunction portalRestrictionErrorMessage(name, type) {\n  return `The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`;\n}\n\nfunction getNodeRestrictionsDescriptors(node, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  } // getPropertyDescriptor here recursively looks up the prototype chain\n  // and returns the first descriptor for the property\n\n\n  const originalTextContentDescriptor = getPropertyDescriptor(node, 'textContent');\n  const originalNodeValueDescriptor = getPropertyDescriptor(node, 'nodeValue');\n  const {\n    appendChild,\n    insertBefore,\n    removeChild,\n    replaceChild\n  } = node;\n  return {\n    appendChild: generateDataDescriptor({\n      value(aChild) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('appendChild', 'method'));\n        }\n\n        return appendChild.call(this, aChild);\n      }\n\n    }),\n    insertBefore: generateDataDescriptor({\n      value(newNode, referenceNode) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('insertBefore', 'method'));\n        }\n\n        return insertBefore.call(this, newNode, referenceNode);\n      }\n\n    }),\n    removeChild: generateDataDescriptor({\n      value(aChild) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('removeChild', 'method'));\n        }\n\n        return removeChild.call(this, aChild);\n      }\n\n    }),\n    replaceChild: generateDataDescriptor({\n      value(newChild, oldChild) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('replaceChild', 'method'));\n        }\n\n        return replaceChild.call(this, newChild, oldChild);\n      }\n\n    }),\n    nodeValue: generateAccessorDescriptor({\n      get() {\n        return originalNodeValueDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('nodeValue', 'property'));\n        }\n\n        originalNodeValueDescriptor.set.call(this, value);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('textContent', 'property'));\n        }\n\n        originalTextContentDescriptor.set.call(this, value);\n      }\n\n    })\n  };\n}\n\nfunction getElementRestrictionsDescriptors(elm, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const descriptors = getNodeRestrictionsDescriptors(elm, options);\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('innerHTML', 'property'), getAssociatedVMIfPresent(this));\n        }\n\n        return originalInnerHTMLDescriptor.set.call(this, value);\n      }\n\n    }),\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n      }\n\n    })\n  });\n  return descriptors;\n}\n\nfunction getShadowRootRestrictionsDescriptors(sr, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  } // Disallowing properties in dev mode only to avoid people doing the wrong\n  // thing when using the real shadow root, because if that's the case,\n  // the component will not work when running with synthetic shadow.\n\n\n  const originalQuerySelector = sr.querySelector;\n  const originalQuerySelectorAll = sr.querySelectorAll;\n  const originalAddEventListener = sr.addEventListener;\n  const descriptors = getNodeRestrictionsDescriptors(sr, options);\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n  assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${toString(sr)} by adding an event listener for \"${type}\".`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${toString(sr)} by adding an event listener for \"${type}\".`); // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into its Component's shadow root\n\n        if (!isUndefined(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    }),\n    querySelector: generateDataDescriptor({\n      value() {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`); // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n        return originalQuerySelector.apply(this, arguments);\n      }\n\n    }),\n    querySelectorAll: generateDataDescriptor({\n      value() {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`); // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n        return originalQuerySelectorAll.apply(this, arguments);\n      }\n\n    })\n  });\n  const BlockedShadowRootMethods = {\n    cloneNode: 0,\n    getElementById: 0,\n    getSelection: 0,\n    elementsFromPoint: 0,\n    dispatchEvent: 0\n  };\n  forEach.call(getOwnPropertyNames(BlockedShadowRootMethods), methodName => {\n    const descriptor = generateAccessorDescriptor({\n      get() {\n        throw new Error(`Disallowed method \"${methodName}\" in ShadowRoot.`);\n      }\n\n    });\n    descriptors[methodName] = descriptor;\n  });\n  return descriptors;\n} // Custom Elements Restrictions:\n// -----------------------------\n\n\nfunction getCustomElementRestrictionsDescriptors(elm, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const descriptors = getNodeRestrictionsDescriptors(elm, options);\n  const originalAddEventListener = elm.addEventListener;\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n  return assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n      }\n\n    }),\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${toString(this)} by adding an event listener for \"${type}\".`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${toString(elm)} by adding an event listener for \"${type}\".`); // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into a lighting element node\n\n        if (!isUndefined(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    })\n  });\n}\n\nfunction getComponentRestrictionsDescriptors() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  return {\n    tagName: generateAccessorDescriptor({\n      get() {\n        throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.`);\n      },\n\n      configurable: true,\n      enumerable: false\n    })\n  };\n}\n\nfunction getLightningElementPrototypeRestrictionsDescriptors(proto) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const originalDispatchEvent = proto.dispatchEvent;\n  const descriptors = {\n    dispatchEvent: generateDataDescriptor({\n      value(event) {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom element for ${getComponentTag(vm)} because no one is listening just yet.`);\n\n        if (!isNull(event) && isObject$1(event)) {\n          const {\n            type\n          } = event;\n\n          if (!/^[a-z][a-z0-9_]*$/.test(type)) {\n            logError(`Invalid event type \"${type}\" dispatched in element ${getComponentTag(vm)}. Event name must start with a lowercase letter and followed only lowercase letters, numbers, and underscores`, vm);\n          }\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalDispatchEvent.apply(this, arguments);\n      }\n\n    })\n  };\n  forEach.call(getOwnPropertyNames(globalHTMLProperties), propName => {\n    if (propName in proto) {\n      return; // no need to redefine something that we are already exposing\n    }\n\n    descriptors[propName] = generateAccessorDescriptor({\n      get() {\n        const {\n          error,\n          attribute\n        } = globalHTMLProperties[propName];\n        const msg = [];\n        msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n\n        if (error) {\n          msg.push(error);\n        } else if (attribute) {\n          msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n        }\n\n        logError(msg.join('\\n'), getAssociatedVM(this));\n      },\n\n      set() {\n        const {\n          readOnly\n        } = globalHTMLProperties[propName];\n\n        if (readOnly) {\n          logError(`The global HTML property \\`${propName}\\` is read-only.`, getAssociatedVM(this));\n        }\n      }\n\n    });\n  });\n  return descriptors;\n}\n\nfunction markNodeFromVNode(node) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  node.$fromTemplate$ = true;\n}\nfunction patchElementWithRestrictions(elm, options) {\n  defineProperties(elm, getElementRestrictionsDescriptors(elm, options));\n} // This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\n\nfunction patchShadowRootWithRestrictions(sr, options) {\n  defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));\n}\nfunction patchCustomElementWithRestrictions(elm, options) {\n  const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);\n  const elmProto = getPrototypeOf(elm);\n  setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp) {\n  defineProperties(cmp, getComponentRestrictionsDescriptors());\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n  defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst noop = () => void 0;\n\nfunction observeElementChildNodes(elm) {\n  elm.$domManual$ = true;\n}\n\nfunction setElementShadowToken(elm, token) {\n  elm.$shadowToken$ = token;\n}\n\nfunction updateNodeHook(oldVnode, vnode) {\n  const {\n    text\n  } = vnode;\n\n  if (oldVnode.text !== text) {\n    if (process.env.NODE_ENV !== 'production') {\n      unlockDomMutation();\n    }\n    /**\n     * Compiler will never produce a text property that is not string\n     */\n\n\n    vnode.elm.nodeValue = text;\n\n    if (process.env.NODE_ENV !== 'production') {\n      lockDomMutation();\n    }\n  }\n}\nfunction insertNodeHook(vnode, parentNode, referenceNode) {\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  parentNode.insertBefore(vnode.elm, referenceNode);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction removeNodeHook(vnode, parentNode) {\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  parentNode.removeChild(vnode.elm);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction createElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n  contextModule.create(vnode);\n}\nvar LWCDOMMode;\n\n(function (LWCDOMMode) {\n  LWCDOMMode[\"manual\"] = \"manual\";\n})(LWCDOMMode || (LWCDOMMode = {}));\n\nfunction fallbackElmHook(vnode) {\n  const {\n    owner\n  } = vnode;\n  const elm = vnode.elm;\n\n  if (isTrue$1(useSyntheticShadow)) {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const {\n      shadowAttribute\n    } = owner.context;\n\n    if (!isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {\n      // this element will now accept any manual content inserted into it\n      observeElementChildNodes(elm);\n    } // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const isPortal = !isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;\n    patchElementWithRestrictions(elm, {\n      isPortal\n    });\n  }\n}\nfunction updateElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction insertCustomElmHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm);\n  appendVM(vm);\n}\nfunction updateChildrenHook(oldVnode, vnode) {\n  const {\n    children,\n    owner\n  } = vnode;\n  const fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;\n  runWithBoundaryProtection(owner, owner.owner, noop, () => {\n    fn(vnode.elm, oldVnode.children, children);\n  }, noop);\n}\nfunction allocateChildrenHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm);\n  const {\n    children\n  } = vnode;\n  vm.aChildren = children;\n\n  if (isTrue$1(useSyntheticShadow)) {\n    // slow path\n    allocateInSlot(vm, children); // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n\n    vnode.children = EmptyArray;\n  }\n}\nfunction createViewModelHook(vnode) {\n  const elm = vnode.elm;\n\n  if (!isUndefined(getAssociatedVMIfPresent(elm))) {\n    // There is a possibility that a custom element is registered under tagName,\n    // in which case, the initialization is already carry on, and there is nothing else\n    // to do here since this hook is called right after invoking `document.createElement`.\n    return;\n  }\n\n  const {\n    mode,\n    ctor,\n    owner\n  } = vnode;\n  const def = getComponentDef(ctor);\n  setElementProto(elm, def);\n\n  if (isTrue$1(useSyntheticShadow)) {\n    const {\n      shadowAttribute\n    } = owner.context; // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  createVM(elm, ctor, {\n    mode,\n    owner\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    patchCustomElementWithRestrictions(elm, EmptyObject);\n  }\n}\nfunction createCustomElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n  contextModule.create(vnode);\n}\nfunction createChildrenHook(vnode) {\n  const {\n    elm,\n    children\n  } = vnode;\n\n  for (let j = 0; j < children.length; ++j) {\n    const ch = children[j];\n\n    if (ch != null) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, elm, null);\n    }\n  }\n}\nfunction rerenderCustomElmHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n  }\n\n  rerenderVM(vm);\n}\nfunction updateCustomElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction removeElmHook(vnode) {\n  // this method only needs to search on child vnodes from template\n  // to trigger the remove hook just in case some of those children\n  // are custom elements.\n  const {\n    children,\n    elm\n  } = vnode;\n\n  for (let j = 0, len = children.length; j < len; ++j) {\n    const ch = children[j];\n\n    if (!isNull(ch)) {\n      ch.hook.remove(ch, elm);\n    }\n  }\n}\nfunction removeCustomElmHook(vnode) {\n  // for custom elements we don't have to go recursively because the removeVM routine\n  // will take care of disconnecting any child VM attached to its shadow as well.\n  removeVM(getAssociatedVM(vnode.elm));\n} // Using a WeakMap instead of a WeakSet because this one works in IE11 :(\n\nconst FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration\n// in a template, and will require a more complex diffing algo.\n\nfunction markAsDynamicChildren(children) {\n  FromIteration.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n  return FromIteration.has(children);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create(null);\nconst hooks = ['wiring', 'locator', 'rendered', 'connected', 'disconnected'];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\n\nfunction register(service) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isObject$1(service), `Invalid service declaration, ${service}: service must be an object`);\n  }\n\n  for (let i = 0; i < hooks.length; ++i) {\n    const hookName = hooks[i];\n\n    if (hookName in service) {\n      let l = Services[hookName];\n\n      if (isUndefined(l)) {\n        Services[hookName] = l = [];\n      }\n\n      ArrayPush.call(l, service[hookName]);\n    }\n  }\n}\nfunction invokeServiceHook(vm, cbs) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n  }\n\n  const {\n    component,\n    data,\n    def,\n    context\n  } = vm;\n\n  for (let i = 0, len = cbs.length; i < len; ++i) {\n    cbs[i].call(undefined, component, data, def, context);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\nconst SymbolIterator = Symbol.iterator;\nconst TextHook = {\n  create: vnode => {\n    vnode.elm = document.createTextNode(vnode.text);\n    linkNodeToShadow(vnode);\n\n    if (process.env.NODE_ENV !== 'production') {\n      markNodeFromVNode(vnode.elm);\n    }\n  },\n  update: updateNodeHook,\n  insert: insertNodeHook,\n  move: insertNodeHook,\n  remove: removeNodeHook\n};\nconst CommentHook = {\n  create: vnode => {\n    vnode.elm = document.createComment(vnode.text);\n    linkNodeToShadow(vnode);\n\n    if (process.env.NODE_ENV !== 'production') {\n      markNodeFromVNode(vnode.elm);\n    }\n  },\n  update: updateNodeHook,\n  insert: insertNodeHook,\n  move: insertNodeHook,\n  remove: removeNodeHook\n}; // insert is called after update, which is used somewhere else (via a module)\n// to mark the vm as inserted, that means we cannot use update as the main channel\n// to rehydrate when dirty, because sometimes the element is not inserted just yet,\n// which breaks some invariants. For that reason, we have the following for any\n// Custom Element that is inserted via a template.\n\nconst ElementHook = {\n  create: vnode => {\n    const {\n      data,\n      sel,\n      clonedElement\n    } = vnode;\n    const {\n      ns\n    } = data; // TODO [#1364]: supporting the ability to inject a cloned StyleElement via a vnode this is\n    // used for style tags for native shadow\n\n    if (isUndefined(clonedElement)) {\n      vnode.elm = isUndefined(ns) ? document.createElement(sel) : document.createElementNS(ns, sel);\n    } else {\n      vnode.elm = clonedElement;\n    }\n\n    linkNodeToShadow(vnode);\n\n    if (process.env.NODE_ENV !== 'production') {\n      markNodeFromVNode(vnode.elm);\n    }\n\n    fallbackElmHook(vnode);\n    createElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateElmHook(oldVnode, vnode);\n    updateChildrenHook(oldVnode, vnode);\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    createChildrenHook(vnode);\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    removeElmHook(vnode);\n  }\n};\nconst CustomElementHook = {\n  create: vnode => {\n    const {\n      sel\n    } = vnode;\n    vnode.elm = document.createElement(sel);\n    linkNodeToShadow(vnode);\n\n    if (process.env.NODE_ENV !== 'production') {\n      markNodeFromVNode(vnode.elm);\n    }\n\n    createViewModelHook(vnode);\n    allocateChildrenHook(vnode);\n    createCustomElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateCustomElmHook(oldVnode, vnode); // in fallback mode, the allocation will always set children to\n    // empty and delegate the real allocation to the slot elements\n\n    allocateChildrenHook(vnode); // in fallback mode, the children will be always empty, so, nothing\n    // will happen, but in native, it does allocate the light dom\n\n    updateChildrenHook(oldVnode, vnode); // this will update the shadowRoot\n\n    rerenderCustomElmHook(vnode);\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    const vm = getAssociatedVM(vnode.elm);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isTrue(vm.state === VMState.created, `${vm} cannot be recycled.`);\n    }\n\n    runConnectedCallback(vm);\n    createChildrenHook(vnode);\n    insertCustomElmHook(vnode);\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    removeCustomElmHook(vnode);\n  }\n};\n\nfunction linkNodeToShadow(vnode) {\n  // TODO [#1164]: this should eventually be done by the polyfill directly\n  vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;\n} // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element\n\n\nfunction addNS(vnode) {\n  const {\n    data,\n    children,\n    sel\n  } = vnode;\n  data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`\n\n  if (isArray$1(children) && sel !== 'foreignObject') {\n    for (let j = 0, n = children.length; j < n; ++j) {\n      const childNode = children[j];\n\n      if (childNode != null && childNode.hook === ElementHook) {\n        addNS(childNode);\n      }\n    }\n  }\n}\n\nfunction addVNodeToChildLWC(vnode) {\n  ArrayPush.call(getVMBeingRendered().velements, vnode);\n} // [h]tml node\n\n\nfunction h(sel, data, children) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n    assert.isTrue(isObject$1(data), `h() 2nd argument data must be an object.`);\n    assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n    assert.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`); // checking reserved internal data properties\n\n    assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    forEach.call(children, childVnode => {\n      if (childVnode != null) {\n        assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n      }\n    });\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: ElementHook,\n    owner: vmBeingRendered\n  };\n\n  if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {\n    addNS(vnode);\n  }\n\n  return vnode;\n} // [t]ab[i]ndex function\n\nfunction ti(value) {\n  // if value is greater than 0, we normalize to 0\n  // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n  // If value is less than -1, we don't care\n  const shouldNormalize = value > 0 && !(isTrue$1(value) || isFalse$1(value));\n\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n\n    if (shouldNormalize) {\n      logError(`Invalid tabindex value \\`${toString(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n    }\n  }\n\n  return shouldNormalize ? 0 : value;\n} // [s]lot element node\n\nfunction s(slotName, data, children, slotset) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n    assert.isTrue(isObject$1(data), `s() 2nd argument data must be an object.`);\n    assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n  }\n\n  if (!isUndefined(slotset) && !isUndefined(slotset[slotName]) && slotset[slotName].length !== 0) {\n    children = slotset[slotName];\n  }\n\n  const vnode = h('slot', data, children);\n\n  if (useSyntheticShadow) {\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(children);\n  }\n\n  return vnode;\n} // [c]ustom element node\n\nfunction c(sel, Ctor, data, children = EmptyArray) {\n  if (isCircularModuleDependency(Ctor)) {\n    Ctor = resolveCircularModuleDependency(Ctor);\n  }\n\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n    assert.isTrue(isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);\n    assert.isTrue(isObject$1(data), `c() 3nd argument data must be an object.`);\n    assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`); // checking reserved internal data properties\n\n    assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    if (arguments.length === 4) {\n      forEach.call(children, childVnode => {\n        if (childVnode != null) {\n          assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n        }\n      });\n    }\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: CustomElementHook,\n    ctor: Ctor,\n    owner: vmBeingRendered,\n    mode: 'open'\n  };\n  addVNodeToChildLWC(vnode);\n  return vnode;\n} // [i]terable node\n\nfunction i(iterable, factory) {\n  const list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(list);\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(iterable) || iterable === null) {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid template iteration for value \"${toString(iterable)}\" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);\n    }\n\n    return list;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isFalse(isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n  }\n\n  const iterator = iterable[SymbolIterator]();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(iterator && isFunction(iterator.next), `Invalid iterator function for \"${toString(iterable)}\" in ${vmBeingRendered}.`);\n  }\n\n  let next = iterator.next();\n  let j = 0;\n  let {\n    value,\n    done: last\n  } = next;\n  let keyMap;\n  let iterationError;\n\n  if (process.env.NODE_ENV !== 'production') {\n    keyMap = create(null);\n  }\n\n  while (last === false) {\n    // implementing a look-back-approach because we need to know if the element is the last\n    next = iterator.next();\n    last = next.done; // template factory logic based on the previous collected value\n\n    const vnode = factory(value, j, j === 0, last);\n\n    if (isArray$1(vnode)) {\n      ArrayPush.apply(list, vnode);\n    } else {\n      ArrayPush.call(list, vnode);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vnodes = isArray$1(vnode) ? vnode : [vnode];\n      forEach.call(vnodes, childVnode => {\n        if (!isNull(childVnode) && isObject$1(childVnode) && !isUndefined(childVnode.sel)) {\n          const {\n            key\n          } = childVnode;\n\n          if (isString(key) || isNumber(key)) {\n            if (keyMap[key] === 1 && isUndefined(iterationError)) {\n              iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n            }\n\n            keyMap[key] = 1;\n          } else if (isUndefined(iterationError)) {\n            iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n          }\n        }\n      });\n    } // preparing next value\n\n\n    j += 1;\n    value = next.value;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(iterationError)) {\n      logError(iterationError, vmBeingRendered);\n    }\n  }\n\n  return list;\n}\n/**\n * [f]lattening\n */\n\nfunction f(items) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');\n  }\n\n  const len = items.length;\n  const flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(flattened);\n\n  for (let j = 0; j < len; j += 1) {\n    const item = items[j];\n\n    if (isArray$1(item)) {\n      ArrayPush.apply(flattened, item);\n    } else {\n      ArrayPush.call(flattened, item);\n    }\n  }\n\n  return flattened;\n} // [t]ext node\n\nfunction t(text) {\n  const data = EmptyObject;\n  let sel, children, key, elm;\n  return {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: TextHook,\n    owner: getVMBeingRendered()\n  };\n} // comment node\n\nfunction p(text) {\n  const data = EmptyObject;\n  const sel = '!';\n  let children, key, elm;\n  return {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: CommentHook,\n    owner: getVMBeingRendered()\n  };\n} // [d]ynamic value to produce a text vnode\n\nfunction d(value) {\n  if (value == null) {\n    return null;\n  }\n\n  return t(value);\n} // [b]ind function\n\nfunction b(fn) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isNull(vmBeingRendered)) {\n    throw new Error();\n  }\n\n  const vm = vmBeingRendered;\n  return function (event) {\n    invokeEventListener(vm, fn, vm.component, event);\n  };\n} // [f]unction_[b]ind\n\nfunction fb(fn) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isNull(vmBeingRendered)) {\n    throw new Error();\n  }\n\n  const vm = vmBeingRendered;\n  return function () {\n    return invokeComponentCallback(vm, fn, ArraySlice$1.call(arguments));\n  };\n} // [l]ocator_[l]istener function\n\nfunction ll(originalHandler, id, context) {\n  const vm = getVMBeingRendered();\n\n  if (isNull(vm)) {\n    throw new Error();\n  } // bind the original handler with b() so we can call it\n  // after resolving the locator\n\n\n  const eventListener = b(originalHandler); // create a wrapping handler to resolve locator, and\n  // then invoke the original handler.\n\n  return function (event) {\n    // located service for the locator metadata\n    const {\n      context: {\n        locator\n      }\n    } = vm;\n\n    if (!isUndefined(locator)) {\n      const {\n        locator: locatorService\n      } = Services;\n\n      if (locatorService) {\n        locator.resolved = {\n          target: id,\n          host: locator.id,\n          targetContext: isFunction(context) && context(),\n          hostContext: isFunction(locator.context) && locator.context()\n        }; // a registered `locator` service will be invoked with\n        // access to the context.locator.resolved, which will contain:\n        // outer id, outer context, inner id, and inner context\n\n        invokeServiceHook(vm, locatorService);\n      }\n    } // invoke original event listener via b()\n\n\n    eventListener(event);\n  };\n} // [k]ey function\n\nfunction k(compilerKey, obj) {\n  switch (typeof obj) {\n    case 'number':\n    case 'string':\n      return compilerKey + ':' + obj;\n\n    case 'object':\n      if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n      }\n\n  }\n} // [g]lobal [id] function\n\nfunction gid(id) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(id) || id === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, vmBeingRendered);\n    }\n\n    return id;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull(id)) {\n    return null;\n  }\n\n  return `${id}-${vmBeingRendered.idx}`;\n} // [f]ragment [id] function\n\nfunction fid(url) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(url) || url === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(url)) {\n        logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, vmBeingRendered);\n      }\n    }\n\n    return url;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull(url)) {\n    return null;\n  } // Apply transformation only for fragment-only-urls\n\n\n  if (/^#/.test(url)) {\n    return `${url}-${vmBeingRendered.idx}`;\n  }\n\n  return url;\n}\n/**\n * Map to store an index value assigned to any dynamic component reference ingested\n * by dc() api. This allows us to generate a unique unique per template per dynamic\n * component reference to avoid diffing algo mismatches.\n */\n\nconst DynamicImportedComponentMap = new Map();\nlet dynamicImportedComponentCounter = 0;\n/**\n * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n */\n\nfunction dc(sel, Ctor, data, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n    assert.isTrue(isObject$1(data), `dc() 3nd argument data must be an object.`);\n    assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);\n  } // null or undefined values should produce a null value in the VNodes\n\n\n  if (Ctor == null) {\n    return null;\n  }\n\n  if (!isComponentConstructor(Ctor)) {\n    throw new Error(`Invalid LWC Constructor ${toString(Ctor)} for custom element <${sel}>.`);\n  }\n\n  let idx = DynamicImportedComponentMap.get(Ctor);\n\n  if (isUndefined(idx)) {\n    idx = dynamicImportedComponentCounter++;\n    DynamicImportedComponentMap.set(Ctor, idx);\n  } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo\n  // to identify different constructors as vnodes with different keys to avoid reusing the\n  // element used for previous constructors.\n\n\n  data.key = `dc:${idx}:${data.key}`;\n  return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n *   - slot element's children: the content of the slot has to be dynamic when in synthetic\n *                              shadow mode because the `vnode.children` might be the slotted\n *                              content vs default content, in which case the size and the\n *                              keys are not matching.\n *   - children that contain dynamic components\n *   - children that are produced by iteration\n *\n */\n\nfunction sc(vnodes) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');\n  } // We have to mark the vnodes collection as dynamic so we can later on\n  // choose to use the snabbdom virtual dom diffing algo instead of our\n  // static dummy algo.\n\n\n  markAsDynamicChildren(vnodes);\n  return vnodes;\n}\n\nvar api = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    h: h,\n    ti: ti,\n    s: s,\n    c: c,\n    i: i,\n    f: f,\n    t: t,\n    p: p,\n    d: d,\n    b: b,\n    fb: fb,\n    ll: ll,\n    k: k,\n    gid: gid,\n    fid: fid,\n    dc: dc,\n    sc: sc\n});\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n  return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n  return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerTemplate(tpl) {\n  signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing\n  // assignment of templates easily, without too much transformation\n\n  return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker\n * Service and other similar libraries to sanitize vulnerable attributes.\n * This API is subject to change or being removed.\n */\n\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n  // locker-service patches this function during runtime to sanitize vulnerable attributes.\n  // when ran off-core this function becomes a noop and returns the user authored value.\n  return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CachedStyleFragments = create(null);\n\nfunction createStyleElement(styleContent) {\n  const elm = document.createElement('style');\n  elm.type = 'text/css';\n  elm.textContent = styleContent;\n  return elm;\n}\n\nfunction getCachedStyleElement(styleContent) {\n  let fragment = CachedStyleFragments[styleContent];\n\n  if (isUndefined(fragment)) {\n    fragment = document.createDocumentFragment();\n    const styleElm = createStyleElement(styleContent);\n    fragment.appendChild(styleElm);\n    CachedStyleFragments[styleContent] = fragment;\n  }\n\n  return fragment.cloneNode(true).firstChild;\n}\n\nconst globalStyleParent = document.head || document.body || document;\nconst InsertedGlobalStyleContent = create(null);\n\nfunction insertGlobalStyle(styleContent) {\n  // inserts the global style when needed, otherwise does nothing\n  if (isUndefined(InsertedGlobalStyleContent[styleContent])) {\n    InsertedGlobalStyleContent[styleContent] = true;\n    const elm = createStyleElement(styleContent);\n    globalStyleParent.appendChild(elm);\n  }\n}\n\nfunction createStyleVNode(elm) {\n  const vnode = h('style', {\n    key: 'style'\n  }, EmptyArray); // TODO [#1364]: supporting the ability to inject a cloned StyleElement\n  // forcing the diffing algo to use the cloned style for native shadow\n\n  vnode.clonedElement = elm;\n  return vnode;\n}\n/**\n * Reset the styling token applied to the host element.\n */\n\n\nfunction resetStyleAttributes(vm) {\n  const {\n    context,\n    elm\n  } = vm; // Remove the style attribute currently applied to the host element.\n\n  const oldHostAttribute = context.hostAttribute;\n\n  if (!isUndefined(oldHostAttribute)) {\n    removeAttribute.call(elm, oldHostAttribute);\n  } // Reset the scoping attributes associated to the context.\n\n\n  context.hostAttribute = context.shadowAttribute = undefined;\n}\n/**\n * Apply/Update the styling token applied to the host element.\n */\n\nfunction applyStyleAttributes(vm, hostAttribute, shadowAttribute) {\n  const {\n    context,\n    elm\n  } = vm; // Remove the style attribute currently applied to the host element.\n\n  setAttribute.call(elm, hostAttribute, '');\n  context.hostAttribute = hostAttribute;\n  context.shadowAttribute = shadowAttribute;\n}\n\nfunction collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {\n  forEach.call(stylesheets, sheet => {\n    if (isArray$1(sheet)) {\n      collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);\n    } else {\n      aggregatorFn(sheet(hostSelector, shadowSelector, isNative));\n    }\n  });\n}\n\nfunction evaluateCSS(stylesheets, hostAttribute, shadowAttribute) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(stylesheets), `Invalid stylesheets.`);\n  }\n\n  if (useSyntheticShadow) {\n    const hostSelector = `[${hostAttribute}]`;\n    const shadowSelector = `[${shadowAttribute}]`;\n    collectStylesheets(stylesheets, hostSelector, shadowSelector, false, textContent => {\n      insertGlobalStyle(textContent);\n    });\n    return null;\n  } else {\n    // Native shadow in place, we need to act accordingly by using the `:host` selector, and an\n    // empty shadow selector since it is not really needed.\n    let buffer = '';\n    collectStylesheets(stylesheets, emptyString, emptyString, true, textContent => {\n      buffer += textContent;\n    });\n    return createStyleVNode(getCachedStyleElement(buffer));\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar GlobalMeasurementPhase;\n\n(function (GlobalMeasurementPhase) {\n  GlobalMeasurementPhase[\"REHYDRATE\"] = \"lwc-rehydrate\";\n  GlobalMeasurementPhase[\"HYDRATE\"] = \"lwc-hydrate\";\n})(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\n\n\nconst isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\nfunction getMarkName(phase, vm) {\n  // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n  // the right measures for components that are recursive.\n  return `${getComponentTag(vm)} - ${phase} - ${vm.idx}`;\n}\n\nfunction getMeasureName(phase, vm) {\n  return `${getComponentTag(vm)} - ${phase}`;\n}\n\nfunction start(markName) {\n  performance.mark(markName);\n}\n\nfunction end(measureName, markName) {\n  performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.\n  // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n\n  performance.clearMarks(markName);\n  performance.clearMarks(measureName);\n}\n\nfunction noop$1() {\n  /* do nothing */\n}\n\nconst startMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  start(markName);\n};\nconst endMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  const measureName = getMeasureName(phase, vm);\n  end(measureName, markName);\n};\nconst startGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);\n  start(markName);\n};\nconst endGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);\n  end(phase, markName);\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n  return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n  vmBeingRendered = vm;\n}\nconst EmptySlots = create(null);\n\nfunction validateSlots(vm, html) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const {\n    cmpSlots = EmptySlots\n  } = vm;\n  const {\n    slots = EmptyArray\n  } = html;\n\n  for (const slotName in cmpSlots) {\n    // eslint-disable-next-line lwc-internal/no-production-assert\n    assert.isTrue(isArray$1(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${toString(cmpSlots[slotName])} for slot \"${slotName}\" in ${vm}.`);\n\n    if (slotName !== '' && ArrayIndexOf.call(slots, slotName) === -1) {\n      // TODO [#1297]: this should never really happen because the compiler should always validate\n      // eslint-disable-next-line lwc-internal/no-production-assert\n      logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm);\n    }\n  }\n}\n\nfunction validateFields(vm, html) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const {\n    component\n  } = vm; // validating identifiers used by template that should be provided by the component\n\n  const {\n    ids = []\n  } = html;\n  forEach.call(ids, propName => {\n    if (!(propName in component)) {\n      // eslint-disable-next-line lwc-internal/no-production-assert\n      logError(`The template rendered by ${vm} references \\`this.${propName}\\`, which is not declared. Check for a typo in the template.`, vm);\n    }\n  });\n}\n\nfunction evaluateTemplate(vm, html) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isFunction(html), `evaluateTemplate() second argument must be an imported template instead of ${toString(html)}`);\n  }\n\n  const isUpdatingTemplateInception = isUpdatingTemplate;\n  const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n  let vnodes = [];\n  runWithBoundaryProtection(vm, vm.owner, () => {\n    // pre\n    vmBeingRendered = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('render', vm);\n    }\n  }, () => {\n    // job\n    const {\n      component,\n      context,\n      cmpSlots,\n      cmpTemplate,\n      tro\n    } = vm;\n    tro.observe(() => {\n      // reset the cache memoizer for template when needed\n      if (html !== cmpTemplate) {\n        // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)\n        if (!isUndefined(cmpTemplate)) {\n          // It is important to reset the content to avoid reusing similar elements generated from a different\n          // template, because they could have similar IDs, and snabbdom just rely on the IDs.\n          resetShadowRoot(vm);\n        } // Check that the template was built by the compiler\n\n\n        if (isUndefined(html) || !isTemplateRegistered(html)) {\n          throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString(html)}.`);\n        }\n\n        vm.cmpTemplate = html; // Populate context with template information\n\n        context.tplCache = create(null);\n        resetStyleAttributes(vm);\n        const {\n          stylesheets,\n          stylesheetTokens\n        } = html;\n\n        if (isUndefined(stylesheets) || stylesheets.length === 0) {\n          context.styleVNode = null;\n        } else if (!isUndefined(stylesheetTokens)) {\n          const {\n            hostAttribute,\n            shadowAttribute\n          } = stylesheetTokens;\n          applyStyleAttributes(vm, hostAttribute, shadowAttribute); // Caching style vnode so it can be reused on every render\n\n          context.styleVNode = evaluateCSS(stylesheets, hostAttribute, shadowAttribute);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          // one time operation for any new template returned by render()\n          // so we can warn if the template is attempting to use a binding\n          // that is not provided by the component instance.\n          validateFields(vm, html);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isObject$1(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`); // validating slots in every rendering since the allocated content might change over time\n\n        validateSlots(vm, html);\n      } // right before producing the vnodes, we clear up all internal references\n      // to custom elements from the template.\n\n\n      vm.velements = []; // Set the global flag that template is being updated\n\n      isUpdatingTemplate = true;\n      vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);\n      const {\n        styleVNode\n      } = context;\n\n      if (!isNull(styleVNode)) {\n        ArrayUnshift$1.call(vnodes, styleVNode);\n      }\n    });\n  }, () => {\n    // post\n    isUpdatingTemplate = isUpdatingTemplateInception;\n    vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('render', vm);\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isArray$1(vnodes), `Compiler should produce html functions that always return an array.`);\n  }\n\n  return vnodes;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n  return vmBeingConstructed === vm;\n}\nfunction invokeComponentCallback(vm, fn, args) {\n  const {\n    component,\n    callHook,\n    context,\n    owner\n  } = vm;\n  let result;\n  runWithBoundaryProtection(vm, owner, () => {\n  }, () => {\n    // job\n    result = callHook(component, fn, args);\n  }, () => {\n  });\n  return result;\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n  const vmBeingConstructedInception = vmBeingConstructed;\n  let error;\n\n  if (process.env.NODE_ENV !== 'production') {\n    startMeasure('constructor', vm);\n  }\n\n  vmBeingConstructed = vm;\n  /**\n   * Constructors don't need to be wrapped with a boundary because for root elements\n   * it should throw, while elements from template are already wrapped by a boundary\n   * associated to the diffing algo.\n   */\n\n  try {\n    // job\n    const result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using\n    // the \"instanceof\" operator would not work here since Locker Service provides its own\n    // implementation of LightningElement, so we indirectly check if the base constructor is\n    // invoked by accessing the component on the vm.\n\n    if (vmBeingConstructed.component !== result) {\n      throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n    }\n  } catch (e) {\n    error = Object(e);\n  } finally {\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('constructor', vm);\n    }\n\n    vmBeingConstructed = vmBeingConstructedInception;\n\n    if (!isUndefined(error)) {\n      error.wcStack = getErrorComponentStack(vm); // re-throwing the original error annotated after restoring the context\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\nfunction invokeComponentRenderMethod(vm) {\n  const {\n    def: {\n      render\n    },\n    callHook,\n    component,\n    context,\n    owner\n  } = vm;\n  const isRenderBeingInvokedInception = isInvokingRender;\n  const vmBeingRenderedInception = getVMBeingRendered();\n  let html;\n  let renderInvocationSuccessful = false;\n  runWithBoundaryProtection(vm, owner, () => {\n    isInvokingRender = true;\n    setVMBeingRendered(vm);\n  }, () => {\n    // job\n    vm.tro.observe(() => {\n      html = callHook(component, render);\n      renderInvocationSuccessful = true;\n    });\n  }, () => {\n    isInvokingRender = isRenderBeingInvokedInception;\n    setVMBeingRendered(vmBeingRenderedInception);\n  }); // If render() invocation failed, process errorCallback in boundary and return an empty template\n\n  return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n  const {\n    callHook,\n    owner,\n    context\n  } = vm;\n  runWithBoundaryProtection(vm, owner, () => {\n  }, () => {\n    // job\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isTrue(isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n    }\n\n    callHook(thisValue, fn, [event]);\n  }, () => {\n  });\n}\n\n/*\n * Copyright (c) 2019, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  create: create$1\n} = Object;\nconst {\n  splice: ArraySplice$1,\n  indexOf: ArrayIndexOf$1,\n  push: ArrayPush$1\n} = Array.prototype;\nconst TargetToReactiveRecordMap = new WeakMap();\n\nfunction isUndefined$1(obj) {\n  return obj === undefined;\n}\n\nfunction getReactiveRecord(target) {\n  let reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (isUndefined$1(reactiveRecord)) {\n    const newRecord = create$1(null);\n    reactiveRecord = newRecord;\n    TargetToReactiveRecordMap.set(target, newRecord);\n  }\n\n  return reactiveRecord;\n}\n\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n  const reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (!isUndefined$1(reactiveRecord)) {\n    const reactiveObservers = reactiveRecord[key];\n\n    if (!isUndefined$1(reactiveObservers)) {\n      for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n        const ro = reactiveObservers[i];\n        ro.notify();\n      }\n    }\n  }\n}\nfunction valueObserved(target, key) {\n  // We should determine if an active Observing Record is present to track mutations.\n  if (currentReactiveObserver === null) {\n    return;\n  }\n\n  const ro = currentReactiveObserver;\n  const reactiveRecord = getReactiveRecord(target);\n  let reactiveObservers = reactiveRecord[key];\n\n  if (isUndefined$1(reactiveObservers)) {\n    reactiveObservers = [];\n    reactiveRecord[key] = reactiveObservers;\n  } else if (reactiveObservers[0] === ro) {\n    return; // perf optimization considering that most subscriptions will come from the same record\n  }\n\n  if (ArrayIndexOf$1.call(reactiveObservers, ro) === -1) {\n    ro.link(reactiveObservers);\n  }\n}\nclass ReactiveObserver {\n  constructor(callback) {\n    this.listeners = [];\n    this.callback = callback;\n  }\n\n  observe(job) {\n    const inceptionReactiveRecord = currentReactiveObserver;\n    currentReactiveObserver = this;\n    let error;\n\n    try {\n      job();\n    } catch (e) {\n      error = Object(e);\n    } finally {\n      currentReactiveObserver = inceptionReactiveRecord;\n\n      if (error !== undefined) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n    }\n  }\n  /**\n   * This method is responsible for disconnecting the Reactive Observer\n   * from any Reactive Record that has a reference to it, to prevent future\n   * notifications about previously recorded access.\n   */\n\n\n  reset() {\n    const {\n      listeners\n    } = this;\n    const len = listeners.length;\n\n    if (len > 0) {\n      for (let i = 0; i < len; i += 1) {\n        const set = listeners[i];\n        const pos = ArrayIndexOf$1.call(listeners[i], this);\n        ArraySplice$1.call(set, pos, 1);\n      }\n\n      listeners.length = 0;\n    }\n  } // friend methods\n\n\n  notify() {\n    this.callback.call(undefined, this);\n  }\n\n  link(reactiveObservers) {\n    ArrayPush$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on\n\n    ArrayPush$1.call(this.listeners, reactiveObservers);\n  }\n\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedComponentToMetaMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerComponent(Ctor, {\n  name,\n  tmpl: template\n}) {\n  signedComponentToMetaMap.set(Ctor, {\n    name,\n    template\n  }); // chaining this method as a way to wrap existing\n  // assignment of component constructor easily, without too much transformation\n\n  return Ctor;\n}\nfunction getComponentRegisteredMeta(Ctor) {\n  return signedComponentToMetaMap.get(Ctor);\n}\nfunction createComponent(uninitializedVm, Ctor) {\n  // create the component instance\n  invokeComponentConstructor(uninitializedVm, Ctor);\n  const initializedVm = uninitializedVm;\n\n  if (isUndefined(initializedVm.component)) {\n    throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);\n  }\n}\nfunction linkComponent(vm) {\n  const {\n    def: {\n      wire\n    }\n  } = vm;\n\n  if (!isUndefined(wire)) {\n    const {\n      wiring\n    } = Services;\n\n    if (wiring) {\n      invokeServiceHook(vm, wiring);\n    }\n  }\n}\nfunction getTemplateReactiveObserver(vm) {\n  return new ReactiveObserver(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.invariant(!isInvokingRender, `Mutating property is not allowed during the rendering life-cycle of ${getVMBeingRendered()}.`);\n      assert.invariant(!isUpdatingTemplate, `Mutating property is not allowed while updating template of ${getVMBeingRendered()}.`);\n    }\n\n    const {\n      isDirty\n    } = vm;\n\n    if (isFalse$1(isDirty)) {\n      markComponentAsDirty(vm);\n      scheduleRehydration(vm);\n    }\n  });\n}\nfunction renderComponent(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n  }\n\n  vm.tro.reset();\n  const vnodes = invokeComponentRenderMethod(vm);\n  vm.isDirty = false;\n  vm.isScheduled = false;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isArray$1(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n  }\n\n  return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n    assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n    assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n    assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n  }\n\n  vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n  if (!isFunction(listener)) {\n    throw new TypeError(); // avoiding problems with non-valid listeners\n  }\n\n  let wrappedListener = cmpEventListenerMap.get(listener);\n\n  if (isUndefined(wrappedListener)) {\n    wrappedListener = function (event) {\n      invokeEventListener(vm, listener, undefined, event);\n    };\n\n    cmpEventListenerMap.set(listener, wrappedListener);\n  }\n\n  return wrappedListener;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createObservedFieldsDescriptorMap(fields) {\n  return ArrayReduce.call(fields, (acc, field) => {\n    acc[field] = createObservedFieldPropertyDescriptor(field);\n    return acc;\n  }, {});\n}\n\nfunction createObservedFieldPropertyDescriptor(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      valueObserved(this, key);\n      return vm.cmpTrack[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (newValue !== vm.cmpTrack[key]) {\n        vm.cmpTrack[key] = newValue;\n\n        if (isFalse$1(vm.isDirty)) {\n          valueMutated(this, key);\n        }\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\n\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(ElementPrototypeAriaPropertyNames, propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n\n  if (!isUndefined(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\nforEach.call(defaultDefHTMLPropertyNames, propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n  // this category, so, better to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n\n  if (!isUndefined(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ShadowRootInnerHTMLSetter = getOwnPropertyDescriptor(ShadowRoot.prototype, 'innerHTML').set;\nconst dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\n\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n  const {\n    get,\n    set,\n    enumerable,\n    configurable\n  } = descriptor;\n\n  if (!isFunction(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  if (!isFunction(set)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  return {\n    enumerable,\n    configurable,\n\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          const name = vm.elm.constructor.name;\n          logError(`\\`${name}\\` constructor can't read the value of property \\`${propName}\\` because the owner component hasn't set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      valueObserved(this, propName);\n      return get.call(vm.elm);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n        assert.invariant(!isUpdatingTemplate, `When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n        assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        assert.invariant(!isObject$1(newValue) || isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n      }\n\n      if (newValue !== vm.cmpProps[propName]) {\n        vm.cmpProps[propName] = newValue;\n\n        if (isFalse$1(vm.isDirty)) {\n          // perf optimization to skip this step if not in the DOM\n          valueMutated(this, propName);\n        }\n      }\n\n      return set.call(vm.elm, newValue);\n    }\n\n  };\n}\n\nfunction getLinkedElement(cmp) {\n  return getAssociatedVM(cmp).elm;\n}\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\n\n\nfunction BaseLightningElementConstructor() {\n  // This should be as performant as possible, while any initialization should be done lazily\n  if (isNull(vmBeingConstructed)) {\n    throw new ReferenceError('Illegal constructor');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(vmBeingConstructed.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${vmBeingConstructed}.`);\n  }\n\n  const vm = vmBeingConstructed;\n  const {\n    elm,\n    mode,\n    def: {\n      ctor\n    }\n  } = vm;\n  const component = this;\n  vm.component = component;\n  vm.tro = getTemplateReactiveObserver(vm);\n  vm.oar = create(null); // interaction hooks\n  // We are intentionally hiding this argument from the formal API of LWCElement because\n  // we don't want folks to know about it just yet.\n\n  if (arguments.length === 1) {\n    const {\n      callHook,\n      setHook,\n      getHook\n    } = arguments[0];\n    vm.callHook = callHook;\n    vm.setHook = setHook;\n    vm.getHook = getHook;\n  } // attaching the shadowRoot\n\n\n  const shadowRootOptions = {\n    mode,\n    delegatesFocus: !!ctor.delegatesFocus\n  };\n  const cmpRoot = elm.attachShadow(shadowRootOptions); // linking elm, shadow root and component with the VM\n\n  associateVM(component, vm);\n  associateVM(cmpRoot, vm);\n  associateVM(elm, vm); // VM is now initialized\n\n  vm.cmpRoot = cmpRoot;\n\n  if (process.env.NODE_ENV !== 'production') {\n    patchComponentWithRestrictions(component);\n    patchShadowRootWithRestrictions(cmpRoot, EmptyObject);\n  }\n\n  return this;\n} // HTML Element - The Good Parts\n\n\nBaseLightningElementConstructor.prototype = {\n  constructor: BaseLightningElementConstructor,\n\n  dispatchEvent(_event) {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch;\n\n    return dispatchEvent.apply(elm, arguments);\n  },\n\n  addEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vmBeingRendered = getVMBeingRendered();\n      assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert.invariant(isFunction(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n    }\n\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    vm.elm.addEventListener(type, wrappedListener, options);\n  },\n\n  removeEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    vm.elm.removeEventListener(type, wrappedListener, options);\n  },\n\n  setAttributeNS(ns, attrName, _value) {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.setAttributeNS.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  removeAttributeNS(ns, attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.removeAttributeNS.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  removeAttribute(attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.removeAttribute.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  setAttribute(attrName, _value) {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.setAttribute.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  getAttribute(attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    const value = elm.getAttribute.apply(elm, arguments);\n    lockAttribute();\n    return value;\n  },\n\n  getAttributeNS(ns, attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    const value = elm.getAttributeNS.apply(elm, arguments);\n    lockAttribute();\n    return value;\n  },\n\n  getBoundingClientRect() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n    }\n\n    return elm.getBoundingClientRect();\n  },\n\n  /**\n   * Returns the first element that is a descendant of node that\n   * matches selectors.\n   */\n  // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n  // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n  querySelector(selectors) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    const {\n      elm\n    } = vm;\n    return elm.querySelector(selectors);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match selectors.\n   */\n  // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,\n  // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,\n  querySelectorAll(selectors) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    const {\n      elm\n    } = vm;\n    return elm.querySelectorAll(selectors);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match the provided tagName.\n   */\n  getElementsByTagName(tagNameOrWildCard) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isFalse(isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    const {\n      elm\n    } = vm;\n    return elm.getElementsByTagName(tagNameOrWildCard);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match the provide classnames.\n   */\n  getElementsByClassName(names) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isFalse(isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    const {\n      elm\n    } = vm;\n    return elm.getElementsByClassName(names);\n  },\n\n  get classList() {\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this); // TODO [#1290]: this still fails in dev but works in production, eventually, we should just throw in all modes\n\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n    }\n\n    return getLinkedElement(this).classList;\n  },\n\n  get template() {\n    const vm = getAssociatedVM(this);\n    return vm.cmpRoot;\n  },\n\n  get shadowRoot() {\n    // From within the component instance, the shadowRoot is always\n    // reported as \"closed\". Authors should rely on this.template instead.\n    return null;\n  },\n\n  render() {\n    const vm = getAssociatedVM(this);\n    return vm.def.template;\n  },\n\n  toString() {\n    const vm = getAssociatedVM(this);\n    return `[object ${vm.def.name}]`;\n  }\n\n}; // Typescript is inferring the wrong function type for this particular\n// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n// @ts-ignore type-mismatch\n\nconst baseDescriptors = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (descriptors, propName) => {\n  descriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n  return descriptors;\n}, create(null));\ndefineProperties(BaseLightningElementConstructor.prototype, baseDescriptors);\n\nif (process.env.NODE_ENV !== 'production') {\n  patchLightningElementPrototypeWithRestrictions(BaseLightningElementConstructor.prototype);\n}\n\nfreeze(BaseLightningElementConstructor);\nseal(BaseLightningElementConstructor.prototype); // @ts-ignore\n\nconst BaseLightningElement = BaseLightningElementConstructor;\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst {\n  isArray: isArray$2\n} = Array;\nconst {\n  getPrototypeOf: getPrototypeOf$1,\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  defineProperties: ObjectDefineProperties,\n  isExtensible,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,\n  getOwnPropertyNames: getOwnPropertyNames$1,\n  getOwnPropertySymbols,\n  preventExtensions,\n  hasOwnProperty: hasOwnProperty$2\n} = Object;\nconst {\n  push: ArrayPush$2,\n  concat: ArrayConcat,\n  map: ArrayMap$1\n} = Array.prototype;\nconst OtS$1 = {}.toString;\n\nfunction toString$1(obj) {\n  if (obj && obj.toString) {\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS$1.call(obj);\n  } else {\n    return obj + '';\n  }\n}\n\nfunction isUndefined$2(obj) {\n  return obj === undefined;\n}\n\nfunction isFunction$1(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject$2(obj) {\n  return typeof obj === 'object';\n}\n\nconst proxyToValueMap = new WeakMap();\n\nfunction registerProxy(proxy, value) {\n  proxyToValueMap.set(proxy, value);\n}\n\nconst unwrap = replicaOrAny => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nfunction wrapValue(membrane, value) {\n  return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n}\n/**\n * Unwrap property descriptors will set value on original descriptor\n * We only need to unwrap if value is specified\n * @param descriptor external descrpitor provided to define new property on original value\n */\n\n\nfunction unwrapDescriptor(descriptor) {\n  if (hasOwnProperty$2.call(descriptor, 'value')) {\n    descriptor.value = unwrap(descriptor.value);\n  }\n\n  return descriptor;\n}\n\nfunction lockShadowTarget(membrane, shadowTarget, originalTarget) {\n  const targetKeys = ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  targetKeys.forEach(key => {\n    let descriptor = getOwnPropertyDescriptor$1(originalTarget, key); // We do not need to wrap the descriptor if configurable\n    // Because we can deal with wrapping it when user goes through\n    // Get own property descriptor. There is also a chance that this descriptor\n    // could change sometime in the future, so we can defer wrapping\n    // until we need to\n\n    if (!descriptor.configurable) {\n      descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n    }\n\n    ObjectDefineProperty(shadowTarget, key, descriptor);\n  });\n  preventExtensions(shadowTarget);\n}\n\nclass ReactiveProxyHandler {\n  constructor(membrane, value) {\n    this.originalTarget = value;\n    this.membrane = membrane;\n  }\n\n  get(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const value = originalTarget[key];\n    const {\n      valueObserved\n    } = membrane;\n    valueObserved(originalTarget, key);\n    return membrane.getProxy(value);\n  }\n\n  set(shadowTarget, key, value) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    const oldValue = originalTarget[key];\n\n    if (oldValue !== value) {\n      originalTarget[key] = value;\n      valueMutated(originalTarget, key);\n    } else if (key === 'length' && isArray$2(originalTarget)) {\n      // fix for issue #236: push will add the new index, and by the time length\n      // is updated, the internal length is already equal to the new length value\n      // therefore, the oldValue is equal to the value. This is the forking logic\n      // to support this use case.\n      valueMutated(originalTarget, key);\n    }\n\n    return true;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    delete originalTarget[key];\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n  apply(shadowTarget, thisArg, argArray) {\n    /* No op */\n  }\n\n  construct(target, argArray, newTarget) {\n    /* No op */\n  }\n\n  has(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved\n      }\n    } = this;\n    valueObserved(originalTarget, key);\n    return key in originalTarget;\n  }\n\n  ownKeys(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  }\n\n  isExtensible(shadowTarget) {\n    const shadowIsExtensible = isExtensible(shadowTarget);\n\n    if (!shadowIsExtensible) {\n      return shadowIsExtensible;\n    }\n\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const targetIsExtensible = isExtensible(originalTarget);\n\n    if (!targetIsExtensible) {\n      lockShadowTarget(membrane, shadowTarget, originalTarget);\n    }\n\n    return targetIsExtensible;\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString$1(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n    }\n  }\n\n  getPrototypeOf(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return getPrototypeOf$1(originalTarget);\n  }\n\n  getOwnPropertyDescriptor(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueObserved\n    } = this.membrane; // keys looked up via hasOwnProperty need to be reactive\n\n    valueObserved(originalTarget, key);\n    let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n\n    if (isUndefined$2(desc)) {\n      return desc;\n    }\n\n    const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n\n    if (!isUndefined$2(shadowDescriptor)) {\n      return shadowDescriptor;\n    } // Note: by accessing the descriptor, the key is marked as observed\n    // but access to the value, setter or getter (if available) cannot observe\n    // mutations, just like regular methods, in which case we just do nothing.\n\n\n    desc = wrapDescriptor(membrane, desc, wrapValue);\n\n    if (!desc.configurable) {\n      // If descriptor from original target is not configurable,\n      // We must copy the wrapped descriptor over to the shadow target.\n      // Otherwise, proxy will throw an invariant error.\n      // This is our last chance to lock the value.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n      ObjectDefineProperty(shadowTarget, key, desc);\n    }\n\n    return desc;\n  }\n\n  preventExtensions(shadowTarget) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    lockShadowTarget(membrane, shadowTarget, originalTarget);\n    preventExtensions(originalTarget);\n    return true;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueMutated\n    } = membrane;\n    const {\n      configurable\n    } = descriptor; // We have to check for value in descriptor\n    // because Object.freeze(proxy) calls this method\n    // with only { configurable: false, writeable: false }\n    // Additionally, method will only be called with writeable:false\n    // if the descriptor has a value, as opposed to getter/setter\n    // So we can just check if writable is present and then see if\n    // value is present. This eliminates getter and setter descriptors\n\n    if (hasOwnProperty$2.call(descriptor, 'writable') && !hasOwnProperty$2.call(descriptor, 'value')) {\n      const originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);\n      descriptor.value = originalDescriptor.value;\n    }\n\n    ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n\n    if (configurable === false) {\n      ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n    }\n\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n}\n\nfunction wrapReadOnlyValue(membrane, value) {\n  return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n}\n\nclass ReadOnlyHandler {\n  constructor(membrane, value) {\n    this.originalTarget = value;\n    this.membrane = membrane;\n  }\n\n  get(shadowTarget, key) {\n    const {\n      membrane,\n      originalTarget\n    } = this;\n    const value = originalTarget[key];\n    const {\n      valueObserved\n    } = membrane;\n    valueObserved(originalTarget, key);\n    return membrane.getReadOnlyProxy(value);\n  }\n\n  set(shadowTarget, key, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  apply(shadowTarget, thisArg, argArray) {\n    /* No op */\n  }\n\n  construct(target, argArray, newTarget) {\n    /* No op */\n  }\n\n  has(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved\n      }\n    } = this;\n    valueObserved(originalTarget, key);\n    return key in originalTarget;\n  }\n\n  ownKeys(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n    }\n  }\n\n  getOwnPropertyDescriptor(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueObserved\n    } = membrane; // keys looked up via hasOwnProperty need to be reactive\n\n    valueObserved(originalTarget, key);\n    let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n\n    if (isUndefined$2(desc)) {\n      return desc;\n    }\n\n    const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n\n    if (!isUndefined$2(shadowDescriptor)) {\n      return shadowDescriptor;\n    } // Note: by accessing the descriptor, the key is marked as observed\n    // but access to the value or getter (if available) cannot be observed,\n    // just like regular methods, in which case we just do nothing.\n\n\n    desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n\n    if (hasOwnProperty$2.call(desc, 'set')) {\n      desc.set = undefined; // readOnly membrane does not allow setters\n    }\n\n    if (!desc.configurable) {\n      // If descriptor from original target is not configurable,\n      // We must copy the wrapped descriptor over to the shadow target.\n      // Otherwise, proxy will throw an invariant error.\n      // This is our last chance to lock the value.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n      ObjectDefineProperty(shadowTarget, key, desc);\n    }\n\n    return desc;\n  }\n\n  preventExtensions(shadowTarget) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n    }\n\n    return false;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n}\n\nfunction extract(objectOrArray) {\n  if (isArray$2(objectOrArray)) {\n    return objectOrArray.map(item => {\n      const original = unwrap(item);\n\n      if (original !== item) {\n        return extract(original);\n      }\n\n      return item;\n    });\n  }\n\n  const obj = ObjectCreate(getPrototypeOf$1(objectOrArray));\n  const names = getOwnPropertyNames$1(objectOrArray);\n  return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {\n    const item = objectOrArray[key];\n    const original = unwrap(item);\n\n    if (original !== item) {\n      seed[key] = extract(original);\n    } else {\n      seed[key] = item;\n    }\n\n    return seed;\n  }, obj);\n}\n\nconst formatter = {\n  header: plainOrProxy => {\n    const originalTarget = unwrap(plainOrProxy); // if originalTarget is falsy or not unwrappable, exit\n\n    if (!originalTarget || originalTarget === plainOrProxy) {\n      return null;\n    }\n\n    const obj = extract(plainOrProxy);\n    return ['object', {\n      object: obj\n    }];\n  },\n  hasBody: () => {\n    return false;\n  },\n  body: () => {\n    return null;\n  }\n}; // Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n\nfunction getGlobal() {\n  // the only reliable means to get the global object is `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  } // Gracefully degrade if not able to locate the global object\n\n\n  return {};\n}\n\nfunction init() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const global = getGlobal(); // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n  //  - Go to Settings,\n  //  - Under console, select \"Enable custom formatters\"\n  // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n\n  const devtoolsFormatters = global.devtoolsFormatters || [];\n  ArrayPush$2.call(devtoolsFormatters, formatter);\n  global.devtoolsFormatters = devtoolsFormatters;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  init();\n}\n\nfunction createShadowTarget(value) {\n  let shadowTarget = undefined;\n\n  if (isArray$2(value)) {\n    shadowTarget = [];\n  } else if (isObject$2(value)) {\n    shadowTarget = {};\n  }\n\n  return shadowTarget;\n}\n\nconst ObjectDotPrototype = Object.prototype;\n\nfunction defaultValueIsObservable(value) {\n  // intentionally checking for null\n  if (value === null) {\n    return false;\n  } // treat all non-object types, including undefined, as non-observable values\n\n\n  if (typeof value !== 'object') {\n    return false;\n  }\n\n  if (isArray$2(value)) {\n    return true;\n  }\n\n  const proto = getPrototypeOf$1(value);\n  return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null;\n}\n\nconst defaultValueObserved = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueMutated = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueDistortion = value => value;\n\nfunction wrapDescriptor(membrane, descriptor, getValue) {\n  const {\n    set,\n    get\n  } = descriptor;\n\n  if (hasOwnProperty$2.call(descriptor, 'value')) {\n    descriptor.value = getValue(membrane, descriptor.value);\n  } else {\n    if (!isUndefined$2(get)) {\n      descriptor.get = function () {\n        // invoking the original getter with the original target\n        return getValue(membrane, get.call(unwrap(this)));\n      };\n    }\n\n    if (!isUndefined$2(set)) {\n      descriptor.set = function (value) {\n        // At this point we don't have a clear indication of whether\n        // or not a valid mutation will occur, we don't have the key,\n        // and we are not sure why and how they are invoking this setter.\n        // Nevertheless we preserve the original semantics by invoking the\n        // original setter with the original target and the unwrapped value\n        set.call(unwrap(this), membrane.unwrapProxy(value));\n      };\n    }\n  }\n\n  return descriptor;\n}\n\nclass ReactiveMembrane {\n  constructor(options) {\n    this.valueDistortion = defaultValueDistortion;\n    this.valueMutated = defaultValueMutated;\n    this.valueObserved = defaultValueObserved;\n    this.valueIsObservable = defaultValueIsObservable;\n    this.objectGraph = new WeakMap();\n\n    if (!isUndefined$2(options)) {\n      const {\n        valueDistortion,\n        valueMutated,\n        valueObserved,\n        valueIsObservable\n      } = options;\n      this.valueDistortion = isFunction$1(valueDistortion) ? valueDistortion : defaultValueDistortion;\n      this.valueMutated = isFunction$1(valueMutated) ? valueMutated : defaultValueMutated;\n      this.valueObserved = isFunction$1(valueObserved) ? valueObserved : defaultValueObserved;\n      this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n    }\n  }\n\n  getProxy(value) {\n    const unwrappedValue = unwrap(value);\n    const distorted = this.valueDistortion(unwrappedValue);\n\n    if (this.valueIsObservable(distorted)) {\n      const o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly\n      // we return the readonly.\n\n      return o.readOnly === value ? value : o.reactive;\n    }\n\n    return distorted;\n  }\n\n  getReadOnlyProxy(value) {\n    value = unwrap(value);\n    const distorted = this.valueDistortion(value);\n\n    if (this.valueIsObservable(distorted)) {\n      return this.getReactiveState(value, distorted).readOnly;\n    }\n\n    return distorted;\n  }\n\n  unwrapProxy(p) {\n    return unwrap(p);\n  }\n\n  getReactiveState(value, distortedValue) {\n    const {\n      objectGraph\n    } = this;\n    let reactiveState = objectGraph.get(distortedValue);\n\n    if (reactiveState) {\n      return reactiveState;\n    }\n\n    const membrane = this;\n    reactiveState = {\n      get reactive() {\n        const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'reactive', {\n          value: proxy\n        });\n        return proxy;\n      },\n\n      get readOnly() {\n        const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'readOnly', {\n          value: proxy\n        });\n        return proxy;\n      }\n\n    };\n    objectGraph.set(distortedValue, reactiveState);\n    return reactiveState;\n  }\n\n}\n/** version: 0.26.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction valueDistortion(value) {\n  return value;\n}\n\nconst reactiveMembrane = new ReactiveMembrane({\n  valueObserved,\n  valueMutated,\n  valueDistortion\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\n\nconst unwrap$1 = function (value) {\n  const unwrapped = reactiveMembrane.unwrapProxy(value);\n\n  if (unwrapped !== value) {\n    // if value is a proxy, unwrap to access original value and apply distortion\n    return valueDistortion(unwrapped);\n  }\n\n  return value;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\n\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\n\nfunction createGetter(key) {\n  let fn = cachedGetterByKey[key];\n\n  if (isUndefined(fn)) {\n    fn = cachedGetterByKey[key] = function () {\n      const vm = getAssociatedVM(this);\n      const {\n        getHook\n      } = vm;\n      return getHook(vm.component, key);\n    };\n  }\n\n  return fn;\n}\n\nfunction createSetter(key) {\n  let fn = cachedSetterByKey[key];\n\n  if (isUndefined(fn)) {\n    fn = cachedSetterByKey[key] = function (newValue) {\n      const vm = getAssociatedVM(this);\n      const {\n        setHook\n      } = vm;\n      newValue = reactiveMembrane.getReadOnlyProxy(newValue);\n      setHook(vm.component, key, newValue);\n    };\n  }\n\n  return fn;\n}\n\nfunction createMethodCaller(methodName) {\n  return function () {\n    const vm = getAssociatedVM(this);\n    const {\n      callHook,\n      component\n    } = vm;\n    const fn = component[methodName];\n    return callHook(vm.component, fn, ArraySlice$1.call(arguments));\n  };\n}\n\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n  let HTMLBridgeElement;\n  /**\n   * Modern browsers will have all Native Constructors as regular Classes\n   * and must be instantiated with the new keyword. In older browsers,\n   * specifically IE11, those are objects with a prototype property defined,\n   * since they are not supposed to be extended or instantiated with the\n   * new keyword. This forking logic supports both cases, specifically because\n   * wc.ts relies on the construction path of the bridges to create new\n   * fully qualifying web components.\n   */\n\n  if (isFunction(SuperClass)) {\n    HTMLBridgeElement = class extends SuperClass {};\n  } else {\n    HTMLBridgeElement = function () {\n      // Bridge classes are not supposed to be instantiated directly in\n      // browsers that do not support web components.\n      throw new TypeError('Illegal constructor');\n    }; // prototype inheritance dance\n\n\n    setPrototypeOf(HTMLBridgeElement, SuperClass);\n    setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n    defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n      writable: true,\n      configurable: true,\n      value: HTMLBridgeElement\n    });\n  }\n\n  const descriptors = create(null); // expose getters and setters for each public props on the new Element Bridge\n\n  for (let i = 0, len = props.length; i < len; i += 1) {\n    const propName = props[i];\n    descriptors[propName] = {\n      get: createGetter(propName),\n      set: createSetter(propName),\n      enumerable: true,\n      configurable: true\n    };\n  } // expose public methods as props on the new Element Bridge\n\n\n  for (let i = 0, len = methods.length; i < len; i += 1) {\n    const methodName = methods[i];\n    descriptors[methodName] = {\n      value: createMethodCaller(methodName),\n      writable: true,\n      configurable: true\n    };\n  }\n\n  defineProperties(HTMLBridgeElement.prototype, descriptors);\n  return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target, prop, descriptor) {\n  if (arguments.length === 1) {\n    return reactiveMembrane.getProxy(target);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length !== 3) {\n      assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n    }\n\n    if (!isUndefined(descriptor)) {\n      const {\n        get,\n        set,\n        configurable,\n        writable\n      } = descriptor;\n      assert.isTrue(!get && !set, `Compiler Error: A @track decorator can only be applied to a public field.`);\n      assert.isTrue(configurable !== false, `Compiler Error: A @track decorator can only be applied to a configurable property.`);\n      assert.isTrue(writable !== false, `Compiler Error: A @track decorator can only be applied to a writable property.`);\n    }\n  }\n\n  return createTrackedPropertyDescriptor(target, prop, isUndefined(descriptor) ? true : descriptor.enumerable === true);\n}\nfunction createTrackedPropertyDescriptor(Ctor, key, enumerable) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      valueObserved(this, key);\n      return vm.cmpTrack[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      const reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);\n\n      if (reactiveOrAnyValue !== vm.cmpTrack[key]) {\n        vm.cmpTrack[key] = reactiveOrAnyValue;\n\n        if (isFalse$1(vm.isDirty)) {\n          // perf optimization to skip this step if the track property is on a component that is already dirty\n          valueMutated(this, key);\n        }\n      }\n    },\n\n    enumerable,\n    configurable: true\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction wireDecorator(target, prop, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(descriptor)) {\n      const {\n        get,\n        set,\n        configurable,\n        writable\n      } = descriptor;\n      assert.isTrue(!get && !set, `Compiler Error: A @wire decorator can only be applied to a public field.`);\n      assert.isTrue(configurable !== false, `Compiler Error: A @wire decorator can only be applied to a configurable property.`);\n      assert.isTrue(writable !== false, `Compiler Error: A @wire decorator can only be applied to a writable property.`);\n    }\n  }\n\n  return createTrackedPropertyDescriptor(target, prop, isObject$1(descriptor) ? descriptor.enumerable === true : true);\n}\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\n\n\nfunction wire(_adapter, _config) {\n  const len = arguments.length;\n\n  if (len > 0 && len < 3) {\n    return wireDecorator;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail('@wire(adapter, config?) may only be used as a decorator.');\n    }\n\n    throw new TypeError();\n  }\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  assign: assign$1,\n  create: create$2,\n  defineProperties: defineProperties$1,\n  defineProperty: defineProperty$1,\n  freeze: freeze$1,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$2,\n  getOwnPropertyNames: getOwnPropertyNames$2,\n  getPrototypeOf: getPrototypeOf$2,\n  hasOwnProperty: hasOwnProperty$3,\n  keys: keys$1,\n  seal: seal$1,\n  setPrototypeOf: setPrototypeOf$1\n} = Object;\n\nfunction isUndefined$3(obj) {\n  return obj === undefined;\n}\n\nfunction isTrue$1$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1$1(obj) {\n  return obj === false;\n}\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when transpiling.\n */\n\n\nconst hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';\n/** version: 1.1.16 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst runtimeFlags = create$2(null); // This function is not supported for use within components and is meant for\n// configuring runtime feature flags during app initialization.\n\nfunction setFeatureFlag(name, value) {\n  const isBoolean = isTrue$1$1(value) || isFalse$1$1(value);\n\n  if (!isBoolean) {\n    const message = `Invalid ${typeof value} value specified for the \"${name}\" flag. Runtime feature flags can only be set to a boolean value.`;\n\n    if (process.env.NODE_ENV === 'production') {\n      // eslint-disable-next-line no-console\n      console.error(message);\n    } else {\n      throw new TypeError(message);\n    }\n  }\n\n  if (!isUndefined$3(featureFlagLookup[name])) {\n    runtimeFlags[name] = value;\n  } else {\n    // eslint-disable-next-line no-console\n    console.warn(`LWC feature flag \"${name}\" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);\n  }\n} // This function is exposed to components to facilitate testing so we add a\n// check to make sure it is not invoked in production.\n\n\nfunction setFeatureFlagForTest(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined$3(featureFlagLookup[name])) {\n      throw new Error(`Feature flag \"${name}\" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);\n    }\n\n    return setFeatureFlag(name, value);\n  }\n}\n\nconst featureFlagLookup = {\n  ENABLE_REACTIVE_SETTER: null,\n  // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.\n  ENABLE_ELEMENT_PATCH: null,\n  ENABLE_NODE_LIST_PATCH: null,\n  ENABLE_HTML_COLLECTIONS_PATCH: null,\n  ENABLE_NODE_PATCH: null\n};\n/** version: 1.1.16 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * @api decorator to mark public fields and public methods in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\n\nfunction api$1(target, propName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length !== 3) {\n      assert.fail(`@api decorator can only be used as a decorator function.`);\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(!descriptor || isFunction(descriptor.get) || isFunction(descriptor.set), `Invalid property ${toString(propName)} definition in ${target}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`);\n\n    if (isObject$1(descriptor) && isFunction(descriptor.set)) {\n      assert.isTrue(isObject$1(descriptor) && isFunction(descriptor.get), `Missing getter for property ${toString(propName)} decorated with @api in ${target}. You cannot have a setter without the corresponding getter.`);\n    }\n  }\n\n  const meta = getDecoratorsRegisteredMeta(target); // initializing getters and setters for each public prop on the target prototype\n\n  if (isObject$1(descriptor) && (isFunction(descriptor.get) || isFunction(descriptor.set))) {\n    // if it is configured as an accessor it must have a descriptor\n    // @ts-ignore it must always be set before calling this method\n    meta.props[propName].config = isFunction(descriptor.set) ? 3 : 1;\n    return createPublicAccessorDescriptor(target, propName, descriptor);\n  } else {\n    // @ts-ignore it must always be set before calling this method\n    meta.props[propName].config = 0;\n    return createPublicPropertyDescriptor(target, propName, descriptor);\n  }\n}\n\nfunction createPublicPropertyDescriptor(proto, key, descriptor) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          const name = vm.elm.constructor.name;\n          logError(`\\`${name}\\` constructor can’t read the value of property \\`${toString(key)}\\` because the owner component hasn’t set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      valueObserved(this, key);\n      return vm.cmpProps[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      vm.cmpProps[key] = newValue; // avoid notification of observability if the instance is already dirty\n\n      if (isFalse$1(vm.isDirty)) {\n        // perf optimization to skip this step if the component is dirty already.\n        valueMutated(this, key);\n      }\n    },\n\n    enumerable: isUndefined(descriptor) ? true : descriptor.enumerable\n  };\n}\n\nclass AccessorReactiveObserver extends ReactiveObserver {\n  constructor(vm, set) {\n    super(() => {\n      if (isFalse$1(this.debouncing)) {\n        this.debouncing = true;\n        addCallbackToNextTick(() => {\n          if (isTrue$1(this.debouncing)) {\n            const {\n              value\n            } = this;\n            const {\n              isDirty: dirtyStateBeforeSetterCall,\n              component,\n              idx\n            } = vm;\n            set.call(component, value); // de-bouncing after the call to the original setter to prevent\n            // infinity loop if the setter itself is mutating things that\n            // were accessed during the previous invocation.\n\n            this.debouncing = false;\n\n            if (isTrue$1(vm.isDirty) && isFalse$1(dirtyStateBeforeSetterCall) && idx > 0) {\n              // immediate rehydration due to a setter driven mutation, otherwise\n              // the component will get rendered on the second tick, which it is not\n              // desirable.\n              rerenderVM(vm);\n            }\n          }\n        });\n      }\n    });\n    this.debouncing = false;\n  }\n\n  reset(value) {\n    super.reset();\n    this.debouncing = false;\n\n    if (arguments.length > 0) {\n      this.value = value;\n    }\n  }\n\n}\n\nfunction createPublicAccessorDescriptor(Ctor, key, descriptor) {\n  const {\n    get,\n    set,\n    enumerable\n  } = descriptor;\n\n  if (!isFunction(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Invalid attempt to create public property descriptor ${toString(key)} in ${Ctor}. It is missing the getter declaration with @api get ${toString(key)}() {} syntax.`);\n    }\n\n    throw new TypeError();\n  }\n\n  return {\n    get() {\n      if (process.env.NODE_ENV !== 'production') {\n        // Assert that the this value is an actual Component with an associated VM.\n        getAssociatedVM(this);\n      }\n\n      return get.call(this);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      if (set) {\n        if (runtimeFlags.ENABLE_REACTIVE_SETTER) {\n          let ro = vm.oar[key];\n\n          if (isUndefined(ro)) {\n            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);\n          } // every time we invoke this setter from outside (through this wrapper setter)\n          // we should reset the value and then debounce just in case there is a pending\n          // invocation the next tick that is not longer relevant since the value is changing\n          // from outside.\n\n\n          ro.reset(newValue);\n          ro.observe(() => {\n            set.call(this, newValue);\n          });\n        } else {\n          set.call(this, newValue);\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`Invalid attempt to set a new value for property ${toString(key)} of ${vm} that does not has a setter decorated with @api.`);\n      }\n    },\n\n    enumerable\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\" in\n * LWC by exposing hooks into the component life-cycle. This API is subject\n * to change or being removed.\n */\n\nfunction decorate(Ctor, decorators) {\n  // intentionally comparing decorators with null and undefined\n  if (!isFunction(Ctor) || decorators == null) {\n    throw new TypeError();\n  }\n\n  const props = getOwnPropertyNames(decorators); // intentionally allowing decoration of classes only for now\n\n  const target = Ctor.prototype;\n\n  for (let i = 0, len = props.length; i < len; i += 1) {\n    const propName = props[i];\n    const decorator = decorators[propName];\n\n    if (!isFunction(decorator)) {\n      throw new TypeError();\n    }\n\n    const originalDescriptor = getOwnPropertyDescriptor(target, propName);\n    const descriptor = decorator(Ctor, propName, originalDescriptor);\n\n    if (!isUndefined(descriptor)) {\n      defineProperty(target, propName, descriptor);\n    }\n  }\n\n  return Ctor; // chaining\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedDecoratorToMetaMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerDecorators(Ctor, meta) {\n  const decoratorMap = create(null);\n  const props = getPublicPropertiesHash(Ctor, meta.publicProps);\n  const methods = getPublicMethodsHash(Ctor, meta.publicMethods);\n  const wire$1 = getWireHash(Ctor, meta.wire);\n  const track$1 = getTrackHash(Ctor, meta.track);\n  const fields = meta.fields;\n  signedDecoratorToMetaMap.set(Ctor, {\n    props,\n    methods,\n    wire: wire$1,\n    track: track$1,\n    fields\n  });\n\n  for (const propName in props) {\n    decoratorMap[propName] = api$1;\n  }\n\n  if (wire$1) {\n    for (const propName in wire$1) {\n      const wireDef = wire$1[propName];\n\n      if (wireDef.method) {\n        // for decorated methods we need to do nothing\n        continue;\n      }\n\n      decoratorMap[propName] = wire(wireDef.adapter, wireDef.params);\n    }\n  }\n\n  if (track$1) {\n    for (const propName in track$1) {\n      decoratorMap[propName] = track;\n    }\n  }\n\n  decorate(Ctor, decoratorMap);\n  return Ctor;\n}\nfunction getDecoratorsRegisteredMeta(Ctor) {\n  return signedDecoratorToMetaMap.get(Ctor);\n}\n\nfunction getTrackHash(target, track) {\n  if (isUndefined(track) || getOwnPropertyNames(track).length === 0) {\n    return EmptyObject;\n  } // TODO [#1302]: check that anything in `track` is correctly defined in the prototype\n\n\n  return assign(create(null), track);\n}\n\nfunction getWireHash(target, wire) {\n  if (isUndefined(wire) || getOwnPropertyNames(wire).length === 0) {\n    return;\n  } // TODO [#1302]: check that anything in `wire` is correctly defined in the prototype\n\n\n  return assign(create(null), wire);\n}\n\nfunction getPublicPropertiesHash(target, props) {\n  if (isUndefined(props) || getOwnPropertyNames(props).length === 0) {\n    return EmptyObject;\n  }\n\n  return getOwnPropertyNames(props).reduce((propsHash, propName) => {\n    const attr = getAttrNameFromPropName(propName);\n    propsHash[propName] = assign({\n      config: 0,\n      type: 'any',\n      attr\n    }, props[propName]);\n    return propsHash;\n  }, create(null));\n}\n\nfunction getPublicMethodsHash(target, publicMethods) {\n  if (isUndefined(publicMethods) || publicMethods.length === 0) {\n    return EmptyObject;\n  }\n\n  return publicMethods.reduce((methodsHash, methodName) => {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isTrue(isFunction(target.prototype[methodName]), `Component \"${target.name}\" should have a method \\`${methodName}\\` instead of ${target.prototype[methodName]}.`);\n    }\n\n    methodsHash[methodName] = target.prototype[methodName];\n    return methodsHash;\n  }, create(null));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\n\nfunction getCtorProto(Ctor, subclassComponentName) {\n  let proto = getPrototypeOf(Ctor);\n\n  if (isNull(proto)) {\n    throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);\n  } // covering the cases where the ref is circular in AMD\n\n\n  if (isCircularModuleDependency(proto)) {\n    const p = resolveCircularModuleDependency(proto);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isNull(p)) {\n        throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);\n      }\n    } // escape hatch for Locker and other abstractions to provide their own base class instead\n    // of our Base class without having to leak it to user-land. If the circular function returns\n    // itself, that's the signal that we have hit the end of the proto chain, which must always\n    // be base.\n\n\n    proto = p === proto ? BaseLightningElement : p;\n  }\n\n  return proto;\n}\n\nfunction createComponentDef(Ctor, meta, subclassComponentName) {\n  if (process.env.NODE_ENV !== 'production') {\n    // local to dev block\n    const ctorName = Ctor.name; // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n    // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n\n    assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n  }\n\n  const {\n    name\n  } = meta;\n  let {\n    template\n  } = meta;\n  const decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);\n  let props = {};\n  let methods = {};\n  let wire;\n  let track = {};\n  let fields;\n\n  if (!isUndefined(decoratorsMeta)) {\n    props = decoratorsMeta.props;\n    methods = decoratorsMeta.methods;\n    wire = decoratorsMeta.wire;\n    track = decoratorsMeta.track;\n    fields = decoratorsMeta.fields;\n  }\n\n  const proto = Ctor.prototype;\n  let {\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  } = proto;\n  const superProto = getCtorProto(Ctor, subclassComponentName);\n  const superDef = superProto !== BaseLightningElement ? getComponentDef(superProto, subclassComponentName) : null;\n  const SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;\n  const bridge = HTMLBridgeElementFactory(SuperBridge, getOwnPropertyNames(props), getOwnPropertyNames(methods));\n\n  if (!isNull(superDef)) {\n    props = assign(create(null), superDef.props, props);\n    methods = assign(create(null), superDef.methods, methods);\n    wire = superDef.wire || wire ? assign(create(null), superDef.wire, wire) : undefined;\n    track = assign(create(null), superDef.track, track);\n    connectedCallback = connectedCallback || superDef.connectedCallback;\n    disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n    renderedCallback = renderedCallback || superDef.renderedCallback;\n    errorCallback = errorCallback || superDef.errorCallback;\n    render = render || superDef.render;\n    template = template || superDef.template;\n  }\n\n  props = assign(create(null), HTML_PROPS, props);\n\n  if (!isUndefined(fields)) {\n    defineProperties(proto, createObservedFieldsDescriptorMap(fields));\n  }\n\n  if (isUndefined(template)) {\n    // default template\n    template = defaultEmptyTemplate;\n  }\n\n  const def = {\n    ctor: Ctor,\n    name,\n    wire,\n    track,\n    props,\n    methods,\n    bridge,\n    template,\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    freeze(Ctor.prototype);\n  }\n\n  return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC\n * constructors. This API is subject to change or being removed.\n */\n\n\nfunction isComponentConstructor(ctor) {\n  if (!isFunction(ctor)) {\n    return false;\n  } // Fast path: LightningElement is part of the prototype chain of the constructor.\n\n\n  if (ctor.prototype instanceof BaseLightningElement) {\n    return true;\n  } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n  // climb up the constructor prototype chain to check in case there are circular dependencies\n  // to resolve.\n\n\n  let current = ctor;\n\n  do {\n    if (isCircularModuleDependency(current)) {\n      const circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end of the proto chain,\n      // which must always be a valid base constructor.\n\n      if (circularResolved === current) {\n        return true;\n      }\n\n      current = circularResolved;\n    }\n\n    if (current === BaseLightningElement) {\n      return true;\n    }\n  } while (!isNull(current) && (current = getPrototypeOf(current))); // Finally return false if the LightningElement is not part of the prototype chain.\n\n\n  return false;\n}\n/**\n * EXPERIMENTAL: This function allows for the collection of internal\n * component metadata. This API is subject to change or being removed.\n */\n\nfunction getComponentDef(Ctor, subclassComponentName) {\n  let def = CtorToDefMap.get(Ctor);\n\n  if (isUndefined(def)) {\n    if (!isComponentConstructor(Ctor)) {\n      throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n    }\n\n    let meta = getComponentRegisteredMeta(Ctor);\n\n    if (isUndefined(meta)) {\n      // TODO [#1295]: remove this workaround after refactoring tests\n      meta = {\n        template: undefined,\n        name: Ctor.name\n      };\n    }\n\n    def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);\n    CtorToDefMap.set(Ctor, def);\n  }\n\n  return def;\n}\n/**\n * EXPERIMENTAL: This function provides access to the component constructor,\n * given an HTMLElement. This API is subject to change or being removed.\n */\n\nfunction getComponentConstructor(elm) {\n  let ctor = null;\n\n  if (elm instanceof HTMLElement) {\n    const vm = getAssociatedVMIfPresent(elm);\n\n    if (!isUndefined(vm)) {\n      ctor = vm.def.ctor;\n    }\n  }\n\n  return ctor;\n} // Only set prototype for public methods and properties\n// No DOM Patching occurs here\n\nfunction setElementProto(elm, def) {\n  setPrototypeOf(elm, def.bridge.prototype);\n} // Typescript is inferring the wrong function type for this particular\n// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n// @ts-ignore type-mismatch\n\nconst HTML_PROPS = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (props, propName) => {\n  const attrName = getAttrNameFromPropName(propName);\n  props[propName] = {\n    config: 3,\n    type: 'any',\n    attr: attrName\n  };\n  return props;\n}, create(null));\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar VMState;\n\n(function (VMState) {\n  VMState[VMState[\"created\"] = 0] = \"created\";\n  VMState[VMState[\"connected\"] = 1] = \"connected\";\n  VMState[VMState[\"disconnected\"] = 2] = \"disconnected\";\n})(VMState || (VMState = {}));\n\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\n\nconst ViewModelReflection = createHiddenField('ViewModel', 'engine');\n\nfunction callHook(cmp, fn, args = []) {\n  return fn.apply(cmp, args);\n}\n\nfunction setHook(cmp, prop, newValue) {\n  cmp[prop] = newValue;\n}\n\nfunction getHook(cmp, prop) {\n  return cmp[prop];\n}\n\nfunction rerenderVM(vm) {\n  rehydrate(vm);\n}\nfunction appendRootVM(vm) {\n  runConnectedCallback(vm);\n  rehydrate(vm);\n}\nfunction appendVM(vm) {\n  rehydrate(vm);\n} // just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\n\nfunction resetComponentStateWhenRemoved(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state !== VMState.disconnected) {\n    const {\n      oar,\n      tro\n    } = vm; // Making sure that any observing record will not trigger the rehydrated on this vm\n\n    tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked\n\n    for (const key in oar) {\n      oar[key].reset();\n    }\n\n    runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n\n    runShadowChildNodesDisconnectedCallback(vm);\n    runLightChildNodesDisconnectedCallback(vm);\n  }\n} // this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\n\n\nfunction removeVM(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, `${vm} must have been connected.`);\n  }\n\n  resetComponentStateWhenRemoved(vm);\n} // this method is triggered by the removal of a root element from the DOM.\n\nfunction removeRootVM(vm) {\n  resetComponentStateWhenRemoved(vm);\n}\nfunction createVM(elm, Ctor, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(elm instanceof HTMLElement, `VM creation requires a DOM element instead of ${elm}.`);\n  }\n\n  const def = getComponentDef(Ctor);\n  const {\n    isRoot,\n    mode,\n    owner\n  } = options;\n  idx += 1;\n  const uninitializedVm = {\n    // component creation index is defined once, and never reset, it can\n    // be preserved from one insertion to another without any issue\n    idx,\n    state: VMState.created,\n    isScheduled: false,\n    isDirty: true,\n    isRoot: isTrue$1(isRoot),\n    mode,\n    def,\n    owner,\n    elm,\n    data: EmptyObject,\n    context: create(null),\n    cmpProps: create(null),\n    cmpTrack: create(null),\n    cmpSlots: useSyntheticShadow ? create(null) : undefined,\n    callHook,\n    setHook,\n    getHook,\n    children: EmptyArray,\n    aChildren: EmptyArray,\n    velements: EmptyArray,\n    // Perf optimization to preserve the shape of this obj\n    cmpTemplate: undefined,\n    component: undefined,\n    cmpRoot: undefined,\n    tro: undefined,\n    oar: undefined\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    uninitializedVm.toString = () => {\n      return `[object:vm ${def.name} (${uninitializedVm.idx})]`;\n    };\n  } // create component instance associated to the vm and the element\n\n\n  createComponent(uninitializedVm, Ctor); // link component to the wire service\n\n  const initializedVm = uninitializedVm;\n  linkComponent(initializedVm);\n}\n\nfunction assertIsVM(obj) {\n  if (isNull(obj) || !isObject$1(obj) || !('cmpRoot' in obj)) {\n    throw new TypeError(`${obj} is not a VM.`);\n  }\n}\n\nfunction associateVM(obj, vm) {\n  setHiddenField(obj, ViewModelReflection, vm);\n}\nfunction getAssociatedVM(obj) {\n  const vm = getHiddenField(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsVM(vm);\n  }\n\n  return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n  const maybeVm = getHiddenField(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(maybeVm)) {\n      assertIsVM(maybeVm);\n    }\n  }\n\n  return maybeVm;\n}\n\nfunction rehydrate(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);\n  }\n\n  if (isTrue$1(vm.isDirty)) {\n    const children = renderComponent(vm);\n    patchShadowRoot(vm, children);\n  }\n}\n\nfunction patchShadowRoot(vm, newCh) {\n  const {\n    cmpRoot,\n    children: oldCh\n  } = vm;\n  vm.children = newCh; // caching the new children collection\n\n  if (newCh.length > 0 || oldCh.length > 0) {\n    // patch function mutates vnodes by adding the element reference,\n    // however, if patching fails it contains partial changes.\n    if (oldCh !== newCh) {\n      const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;\n      runWithBoundaryProtection(vm, vm, () => {\n        // pre\n        if (process.env.NODE_ENV !== 'production') {\n          startMeasure('patch', vm);\n        }\n      }, () => {\n        // job\n        fn(cmpRoot, oldCh, newCh);\n      }, () => {\n        // post\n        if (process.env.NODE_ENV !== 'production') {\n          endMeasure('patch', vm);\n        }\n      });\n    }\n  }\n\n  if (vm.state === VMState.connected) {\n    // If the element is connected, that means connectedCallback was already issued, and\n    // any successive rendering should finish with the call to renderedCallback, otherwise\n    // the connectedCallback will take care of calling it in the right order at the end of\n    // the current rehydration process.\n    runRenderedCallback(vm);\n  }\n}\n\nfunction runRenderedCallback(vm) {\n  const {\n    rendered\n  } = Services;\n\n  if (rendered) {\n    invokeServiceHook(vm, rendered);\n  }\n\n  const {\n    renderedCallback\n  } = vm.def;\n\n  if (!isUndefined(renderedCallback)) {\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('renderedCallback', vm);\n    }\n\n    invokeComponentCallback(vm, renderedCallback);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('renderedCallback', vm);\n    }\n  }\n}\n\nlet rehydrateQueue = [];\n\nfunction flushRehydrationQueue() {\n  startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n  }\n\n  const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n  rehydrateQueue = []; // reset to a new queue\n\n  for (let i = 0, len = vms.length; i < len; i += 1) {\n    const vm = vms[i];\n\n    try {\n      rehydrate(vm);\n    } catch (error) {\n      if (i + 1 < len) {\n        // pieces of the queue are still pending to be rehydrated, those should have priority\n        if (rehydrateQueue.length === 0) {\n          addCallbackToNextTick(flushRehydrationQueue);\n        }\n\n        ArrayUnshift$1.apply(rehydrateQueue, ArraySlice$1.call(vms, i + 1));\n      } // we need to end the measure before throwing.\n\n\n      endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is\n      // already scheduled, it should continue patching the rest.\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n\n  endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n}\n\nfunction runConnectedCallback(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state === VMState.connected) {\n    return; // nothing to do since it was already connected\n  }\n\n  vm.state = VMState.connected; // reporting connection\n\n  const {\n    connected\n  } = Services;\n\n  if (connected) {\n    invokeServiceHook(vm, connected);\n  }\n\n  const {\n    connectedCallback\n  } = vm.def;\n\n  if (!isUndefined(connectedCallback)) {\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('connectedCallback', vm);\n    }\n\n    invokeComponentCallback(vm, connectedCallback);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('connectedCallback', vm);\n    }\n  }\n}\n\nfunction runDisconnectedCallback(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.state !== VMState.disconnected, `${vm} must be inserted.`);\n  }\n\n  if (isFalse$1(vm.isDirty)) {\n    // this guarantees that if the component is reused/reinserted,\n    // it will be re-rendered because we are disconnecting the reactivity\n    // linking, so mutations are not automatically reflected on the state\n    // of disconnected components.\n    vm.isDirty = true;\n  }\n\n  vm.state = VMState.disconnected; // reporting disconnection\n\n  const {\n    disconnected\n  } = Services;\n\n  if (disconnected) {\n    invokeServiceHook(vm, disconnected);\n  }\n\n  const {\n    disconnectedCallback\n  } = vm.def;\n\n  if (!isUndefined(disconnectedCallback)) {\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('disconnectedCallback', vm);\n    }\n\n    invokeComponentCallback(vm, disconnectedCallback);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('disconnectedCallback', vm);\n    }\n  }\n}\n\nfunction runShadowChildNodesDisconnectedCallback(vm) {\n  const {\n    velements: vCustomElementCollection\n  } = vm; // reporting disconnection for every child in inverse order since they are inserted in reserved order\n\n  for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n    const elm = vCustomElementCollection[i].elm; // There are two cases where the element could be undefined:\n    // * when there is an error during the construction phase, and an\n    //   error boundary picks it, there is a possibility that the VCustomElement\n    //   is not properly initialized, and therefore is should be ignored.\n    // * when slotted custom element is not used by the element where it is slotted\n    //   into it, as a result, the custom element was never initialized.\n\n    if (!isUndefined(elm)) {\n      const childVM = getAssociatedVM(elm);\n      resetComponentStateWhenRemoved(childVM);\n    }\n  }\n}\n\nfunction runLightChildNodesDisconnectedCallback(vm) {\n  const {\n    aChildren: adoptedChildren\n  } = vm;\n  recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\n\n\nfunction recursivelyDisconnectChildren(vnodes) {\n  for (let i = 0, len = vnodes.length; i < len; i += 1) {\n    const vnode = vnodes[i];\n\n    if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined(vnode.elm)) {\n      // vnode is a VElement with children\n      if (isUndefined(vnode.ctor)) {\n        // it is a VElement, just keep looking (recursively)\n        recursivelyDisconnectChildren(vnode.children);\n      } else {\n        // it is a VCustomElement, disconnect it and ignore its children\n        resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));\n      }\n    }\n  }\n} // This is a super optimized mechanism to remove the content of the shadowRoot\n// without having to go into snabbdom. Especially useful when the reset is a consequence\n// of an error, in which case the children VNodes might not be representing the current\n// state of the DOM\n\n\nfunction resetShadowRoot(vm) {\n  vm.children = EmptyArray;\n  ShadowRootInnerHTMLSetter.call(vm.cmpRoot, ''); // disconnecting any known custom element inside the shadow of the this vm\n\n  runShadowChildNodesDisconnectedCallback(vm);\n}\nfunction scheduleRehydration(vm) {\n  if (!vm.isScheduled) {\n    vm.isScheduled = true;\n\n    if (rehydrateQueue.length === 0) {\n      addCallbackToNextTick(flushRehydrationQueue);\n    }\n\n    ArrayPush.call(rehydrateQueue, vm);\n  }\n}\n\nfunction getErrorBoundaryVM(vm) {\n  let currentVm = vm;\n\n  while (!isNull(currentVm)) {\n    if (!isUndefined(currentVm.def.errorCallback)) {\n      return currentVm;\n    }\n\n    currentVm = vm.owner;\n  }\n}\n/**\n * EXPERIMENTAL: This function detects whether or not a Node is\n * controlled by a LWC template. This API is subject to\n * change or being removed.\n */\n\n\nfunction isNodeFromTemplate(node) {\n  if (isFalse$1(node instanceof Node)) {\n    return false;\n  } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker\n\n\n  if (node instanceof ShadowRoot) {\n    return false;\n  }\n\n  if (useSyntheticShadow) {\n    // TODO [#1252]: old behavior that is still used by some pieces of the platform, specifically, nodes inserted\n    // manually on places where `lwc:dom=\"manual\"` directive is not used, will be considered global elements.\n    if (isUndefined(node.$shadowResolver$)) {\n      return false;\n    }\n  }\n\n  const root = node.getRootNode();\n  return root instanceof ShadowRoot;\n} // slow path routine\n// NOTE: we should probably more this routine to the synthetic shadow folder\n// and get the allocation to be cached by in the elm instead of in the VM\n\nfunction allocateInSlot(vm, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isObject$1(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);\n  }\n\n  const {\n    cmpSlots: oldSlots\n  } = vm;\n  const cmpSlots = vm.cmpSlots = create(null);\n\n  for (let i = 0, len = children.length; i < len; i += 1) {\n    const vnode = children[i];\n\n    if (isNull(vnode)) {\n      continue;\n    }\n\n    const {\n      data\n    } = vnode;\n    const slotName = data.attrs && data.attrs.slot || '';\n    const vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot\n    // which might have similar keys. Each vnode will always have a key that\n    // starts with a numeric character from compiler. In this case, we add a unique\n    // notation for slotted vnodes keys, e.g.: `@foo:1:1`\n\n    vnode.key = `@${slotName}:${vnode.key}`;\n    ArrayPush.call(vnodes, vnode);\n  }\n\n  if (isFalse$1(vm.isDirty)) {\n    // We need to determine if the old allocation is really different from the new one\n    // and mark the vm as dirty\n    const oldKeys = keys(oldSlots);\n\n    if (oldKeys.length !== keys(cmpSlots).length) {\n      markComponentAsDirty(vm);\n      return;\n    }\n\n    for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n      const key = oldKeys[i];\n\n      if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {\n        markComponentAsDirty(vm);\n        return;\n      }\n\n      const oldVNodes = oldSlots[key];\n      const vnodes = cmpSlots[key];\n\n      for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {\n        if (oldVNodes[j] !== vnodes[j]) {\n          markComponentAsDirty(vm);\n          return;\n        }\n      }\n    }\n  }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n  let error;\n  pre();\n\n  try {\n    job();\n  } catch (e) {\n    error = Object(e);\n  } finally {\n    post();\n\n    if (!isUndefined(error)) {\n      error.wcStack = error.wcStack || getErrorComponentStack(vm);\n      const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);\n\n      if (isUndefined(errorBoundaryVm)) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n\n      resetShadowRoot(vm); // remove offenders\n\n      if (process.env.NODE_ENV !== 'production') {\n        startMeasure('errorCallback', errorBoundaryVm);\n      } // error boundaries must have an ErrorCallback\n\n\n      const errorCallback = errorBoundaryVm.def.errorCallback;\n      invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n\n      if (process.env.NODE_ENV !== 'production') {\n        endMeasure('errorCallback', errorBoundaryVm);\n      }\n    }\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  appendChild,\n  insertBefore,\n  removeChild,\n  replaceChild\n} = Node.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ConnectingSlot = createHiddenField('connecting', 'engine');\nconst DisconnectingSlot = createHiddenField('disconnecting', 'engine');\n\nfunction callNodeSlot(node, slot) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n  }\n\n  const fn = getHiddenField(node, slot);\n\n  if (!isUndefined(fn)) {\n    fn();\n  }\n\n  return node; // for convenience\n} // monkey patching Node methods to be able to detect the insertions and removal of\n// root elements created via createElement.\n\n\nassign(Node.prototype, {\n  appendChild(newChild) {\n    const appendedNode = appendChild.call(this, newChild);\n    return callNodeSlot(appendedNode, ConnectingSlot);\n  },\n\n  insertBefore(newChild, referenceNode) {\n    const insertedNode = insertBefore.call(this, newChild, referenceNode);\n    return callNodeSlot(insertedNode, ConnectingSlot);\n  },\n\n  removeChild(oldChild) {\n    const removedNode = removeChild.call(this, oldChild);\n    return callNodeSlot(removedNode, DisconnectingSlot);\n  },\n\n  replaceChild(newChild, oldChild) {\n    const replacedNode = replaceChild.call(this, newChild, oldChild);\n    callNodeSlot(replacedNode, DisconnectingSlot);\n    callNodeSlot(newChild, ConnectingSlot);\n    return replacedNode;\n  }\n\n});\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement\n * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)\n * with the slightly difference that in the options, you can pass the `is`\n * property set to a Constructor instead of just a string value. The intent\n * is to allow the creation of an element controlled by LWC without having\n * to register the element as a custom element. E.g.:\n *\n * const el = createElement('x-foo', { is: FooCtor });\n *\n * If the value of `is` attribute is not a constructor,\n * then it throws a TypeError.\n */\n\nfunction createElement(sel, options) {\n  if (!isObject$1(options) || isNull(options)) {\n    throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString(options)}\".`);\n  }\n\n  let Ctor = options.is;\n\n  if (!isFunction(Ctor)) {\n    throw new TypeError(`\"createElement\" function expects a \"is\" option with a valid component constructor.`);\n  }\n\n  const mode = options.mode !== 'closed' ? 'open' : 'closed'; // Create element with correct tagName\n\n  const element = document.createElement(sel);\n\n  if (!isUndefined(getAssociatedVMIfPresent(element))) {\n    // There is a possibility that a custom element is registered under tagName,\n    // in which case, the initialization is already carry on, and there is nothing else\n    // to do here.\n    return element;\n  }\n\n  if (isCircularModuleDependency(Ctor)) {\n    Ctor = resolveCircularModuleDependency(Ctor);\n  }\n\n  const def = getComponentDef(Ctor);\n  setElementProto(element, def);\n\n  if (process.env.NODE_ENV !== 'production') {\n    patchCustomElementWithRestrictions(element, EmptyObject);\n  } // In case the element is not initialized already, we need to carry on the manual creation\n\n\n  createVM(element, Ctor, {\n    mode,\n    isRoot: true,\n    owner: null\n  }); // Handle insertion and removal from the DOM manually\n\n  setHiddenField(element, ConnectingSlot, () => {\n    const vm = getAssociatedVM(element);\n    startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);\n\n    if (vm.state === VMState.connected) {\n      // usually means moving the element from one place to another, which is observable via life-cycle hooks\n      removeRootVM(vm);\n    }\n\n    appendRootVM(vm);\n    endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);\n  });\n  setHiddenField(element, DisconnectingSlot, () => {\n    const vm = getAssociatedVM(element);\n    removeRootVM(vm);\n  });\n  return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\n\nfunction readonly(obj) {\n  if (process.env.NODE_ENV !== 'production') {\n    // TODO [#1292]: Remove the readonly decorator\n    if (arguments.length !== 1) {\n      assert.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n    }\n  }\n\n  return reactiveMembrane.getReadOnlyProxy(obj);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor\n * so it can be registered as a new element via customElements.define()\n * at any given time. E.g.:\n *\n *      import { buildCustomElementConstructor } from 'lwc';\n *      import Foo from 'ns/foo';\n *      const WC = buildCustomElementConstructor(Foo);\n *      customElements.define('x-foo', WC);\n *      const elm = document.createElement('x-foo');\n *\n */\n\nfunction buildCustomElementConstructor(Ctor, options) {\n  var _a;\n\n  const {\n    props,\n    bridge: BaseElement\n  } = getComponentDef(Ctor);\n  const normalizedOptions = {\n    mode: 'open',\n    isRoot: true,\n    owner: null\n  };\n\n  if (isObject$1(options) && !isNull(options)) {\n    const {\n      mode\n    } = options;\n\n    if (mode === 'closed') {\n      normalizedOptions.mode = mode;\n    }\n  }\n\n  return _a = class extends BaseElement {\n    constructor() {\n      super();\n      createVM(this, Ctor, normalizedOptions);\n\n      if (process.env.NODE_ENV !== 'production') {\n        patchCustomElementWithRestrictions(this, EmptyObject);\n      }\n    }\n\n    connectedCallback() {\n      const vm = getAssociatedVM(this);\n      appendRootVM(vm);\n    }\n\n    disconnectedCallback() {\n      const vm = getAssociatedVM(this);\n      removeRootVM(vm);\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      if (oldValue === newValue) {\n        // ignoring similar values for better perf\n        return;\n      }\n\n      const propName = getPropNameFromAttrName(attrName);\n\n      if (isUndefined(props[propName])) {\n        // ignoring unknown attributes\n        return;\n      }\n\n      if (!isAttributeLocked(this, attrName)) {\n        // ignoring changes triggered by the engine itself during:\n        // * diffing when public props are attempting to reflect to the DOM\n        // * component via `this.setAttribute()`, should never update the prop.\n        // Both cases, the the setAttribute call is always wrap by the unlocking\n        // of the attribute to be changed\n        return;\n      } // reflect attribute change to the corresponding props when changed\n      // from outside.\n\n\n      this[propName] = newValue;\n    }\n\n  }, // collecting all attribute names from all public props to apply\n  // the reflection from attributes to props via attributeChangedCallback.\n  _a.observedAttributes = ArrayMap.call(getOwnPropertyNames(props), propName => props[propName].attr), _a;\n}\n\nexports.LightningElement = BaseLightningElement;\nexports.api = api$1;\nexports.buildCustomElementConstructor = buildCustomElementConstructor;\nexports.createElement = createElement;\nexports.decorate = decorate;\nexports.getComponentConstructor = getComponentConstructor;\nexports.getComponentDef = getComponentDef;\nexports.isComponentConstructor = isComponentConstructor;\nexports.isNodeFromTemplate = isNodeFromTemplate;\nexports.readonly = readonly;\nexports.register = register;\nexports.registerComponent = registerComponent;\nexports.registerDecorators = registerDecorators;\nexports.registerTemplate = registerTemplate;\nexports.sanitizeAttribute = sanitizeAttribute;\nexports.setFeatureFlag = setFeatureFlag;\nexports.setFeatureFlagForTest = setFeatureFlagForTest;\nexports.track = track;\nexports.unwrap = unwrap$1;\nexports.wire = wire;\n/** version: 1.1.16 */\n"],"sourceRoot":""}